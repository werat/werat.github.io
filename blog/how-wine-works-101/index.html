<!doctype html><html lang=en><head><title>How Wine works 101</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Andy Hippo"><meta name=description content="Wine is a compatibility layer capable of running Windows applications on several POSIX-compliant operating systems, such as Linux, macOS, & BSD (https://www.winehq.org).
If you have been using Linux for some time now, chances are you’ve used Wine at some point. Maybe to run that one very important Windows program that doesn’t have a Linux version or maybe to play World of Warcraft or some other game. Fun fact, Valve&rsquo;s Steam Deck uses a Wine-based solution to run games (called Proton)."><meta name=keywords content="blog,developer,personal,wine,debugging,linux,windows,gaming"><meta name=twitter:card content="summary"><meta name=twitter:title content="How Wine works 101"><meta name=twitter:description content="Wine is a compatibility layer capable of running Windows applications on several POSIX-compliant operating systems, such as Linux, macOS, & BSD (https://www.winehq.org).
If you have been using Linux for some time now, chances are you’ve used Wine at some point. Maybe to run that one very important Windows program that doesn’t have a Linux version or maybe to play World of Warcraft or some other game. Fun fact, Valve&rsquo;s Steam Deck uses a Wine-based solution to run games (called Proton)."><meta property="og:title" content="How Wine works 101"><meta property="og:description" content="Wine is a compatibility layer capable of running Windows applications on several POSIX-compliant operating systems, such as Linux, macOS, & BSD (https://www.winehq.org).
If you have been using Linux for some time now, chances are you’ve used Wine at some point. Maybe to run that one very important Windows program that doesn’t have a Linux version or maybe to play World of Warcraft or some other game. Fun fact, Valve&rsquo;s Steam Deck uses a Wine-based solution to run games (called Proton)."><meta property="og:type" content="article"><meta property="og:url" content="https://werat.dev/blog/how-wine-works-101/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-10T21:20:00+01:00"><meta property="article:modified_time" content="2022-10-10T21:20:00+01:00"><link rel=canonical href=https://werat.dev/blog/how-wine-works-101/><link rel=alternate type=application/rss+xml title=werat.dev href=https://werat.dev/index.xml><link rel=icon href=/favicon.ico sizes=any><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=manifest href=/manifest.webmanifest><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.110.0"></head><body><header class=nav-header><nav><span class=nav-title><a href=/>werat.dev</a></span>
<a href=/posts/>Blog</a>
<a href=/talks/>Talks</a></nav></header><main><article><header><h1 class=title>How Wine works 101</h1><time class=posted-on datetime=2022-10-10T21:20:00+01:00>October 10, 2022</time></header><p><strong>Wine</strong> is a compatibility layer capable of running Windows applications on several POSIX-compliant operating systems, such as Linux, macOS, & BSD (<a href=https://www.winehq.org>https://www.winehq.org</a>).</p><p>If you have been using Linux for some time now, chances are you’ve used Wine at some point. Maybe to run that one very important Windows program that doesn’t have a Linux version or maybe to play World of Warcraft or some other game. Fun fact, Valve&rsquo;s <a href=https://www.steamdeck.com/>Steam Deck</a> uses a Wine-based solution to run games (called <a href=https://github.com/ValveSoftware/Proton/>Proton</a>).</p><p>In the last year I’ve spent quite some time working on a debugger capable of debugging both the Wine layer and the Windows application running with it. It was very interesting to learn about the Wine internals &ndash; I’ve used Wine many times before, but never knew how it worked. If you ever wondered how it’s possible to take a Windows executable and just run it on Linux without any modifications – welcome to this article!</p><h2 id=disclaimer>Disclaimer
<a class=heading-link href=#disclaimer>#</a></h2><p><img src=1.png alt="I have approximate knowledge of many things!" width=1024 height=576 style=width:100%;max-width:600px></p><p>This article greatly simplifies reality and I don&rsquo;t claim to know all the details. However I hope the explanation here will give you a general understanding of how things like Wine work.</p><h2 id=not-an-emulator>Not an Emulator
<a class=heading-link href=#not-an-emulator>#</a></h2><p>Before describing how Wine works, let&rsquo;s explore how it doesn&rsquo;t work. Wine is a recursive acronym and it stands for “Wine Is Not an Emulator”. Why isn’t it? There are lots of great emulators, both for older architecture and for modern consoles. Could Wine be implemented as an emulator? Yep, but there are good reasons not to do this. Let&rsquo;s take a quick look at how emulators work in general.</p><p>Imagine we have some simple hardware, with two instructions:</p><ul><li><code>push &lt;value></code> – pushes given <code>value</code> to the stack</li><li><code>setpxl</code> – pops three values from the stack and draws a pixel with color <code>arg1</code> at <code>(arg2, arg3)</code></li></ul><p>(this should be enough to create some cool demoscenes, right?)</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&gt; dump-instructions game.rom
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span># draw red dot at (10,10)
</span></span><span style=display:flex><span>push 10
</span></span><span style=display:flex><span>push 10
</span></span><span style=display:flex><span>push 0xFF0000
</span></span><span style=display:flex><span>setpxl
</span></span><span style=display:flex><span># draw green dot at (15,15)
</span></span><span style=display:flex><span>push 15
</span></span><span style=display:flex><span>push 15
</span></span><span style=display:flex><span>push 0x00FF00
</span></span><span style=display:flex><span>setpxl
</span></span></code></pre></div><p>The game binary (or ROM cartridge) is a sequence of these instructions, which the hardware can load into the memory and then execute. The <em>real</em> hardware can execute them <em>natively</em>, but what if we want to play the game on our modern laptop? We&rsquo;ll create a software emulator – a program that loads the ROM in memory and then executes its instructions. An interpreter or a virtual machine, if you will. The implementation of the emulator for our two-instructions console can be pretty simple:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#a90d91>enum</span> <span style=color:#3f6e75>Opcode</span> {
</span></span><span style=display:flex><span>    <span style=color:#000>Push</span>(<span style=color:#a90d91>i32</span>),
</span></span><span style=display:flex><span>    <span style=color:#000>SetPixel</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>let</span> <span style=color:#000>program</span>: <span style=color:#a90d91>Vec</span><span style=color:#000>&lt;</span><span style=color:#000>Opcode</span><span style=color:#000>&gt;</span> <span style=color:#000>=</span> <span style=color:#000>read_program</span>(<span style=color:#c41a16>&#34;game.rom&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a90d91>let</span> <span style=color:#a90d91>mut</span> <span style=color:#000>window</span> <span style=color:#000>=</span> <span style=color:#000>create_new_window</span>(<span style=color:#1c01ce>160</span>, <span style=color:#1c01ce>144</span>); <span style=color:#177500>// Virtual screen of 160x144 pixels
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#a90d91>let</span> <span style=color:#a90d91>mut</span> <span style=color:#000>stack</span> <span style=color:#000>=</span> <span style=color:#a90d91>Vec</span>::<span style=color:#000>new</span>(); <span style=color:#177500>// Stack for passing arguments
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span><span style=color:#a90d91>for</span> <span style=color:#000>opcode</span> <span style=color:#a90d91>in</span> <span style=color:#000>program</span> {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>match</span> <span style=color:#000>opcode</span> {
</span></span><span style=display:flex><span>        <span style=color:#000>Opcode</span>::<span style=color:#000>Push</span>(<span style=color:#000>value</span>) <span style=color:#000>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#000>stack</span>.<span style=color:#000>push</span>(<span style=color:#000>value</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#000>Opcode</span>::<span style=color:#000>SetPixel</span> <span style=color:#000>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#a90d91>let</span> <span style=color:#000>color</span> <span style=color:#000>=</span> <span style=color:#000>stack</span>.<span style=color:#000>pop</span>();
</span></span><span style=display:flex><span>            <span style=color:#a90d91>let</span> <span style=color:#000>x</span> <span style=color:#000>=</span> <span style=color:#000>stack</span>.<span style=color:#000>pop</span>();
</span></span><span style=display:flex><span>            <span style=color:#a90d91>let</span> <span style=color:#000>y</span> <span style=color:#000>=</span> <span style=color:#000>stack</span>.<span style=color:#000>pop</span>();
</span></span><span style=display:flex><span>            <span style=color:#000>window</span>.<span style=color:#000>set_pixel</span>(<span style=color:#000>x</span>, <span style=color:#000>y</span>, <span style=color:#000>color</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The real emulators are a lot more complicated, but the basic idea is the same: maintain some context (memory, registers, etc), handle input (e.g. keyboard/mouse) and output (e.g. drawing to some window), parse input data (ROM) and execute the instructions one by one, applying their side-effects.</p><p>This could be one way to implement Wine, but there are two reasons against it. First, the emulators are &ldquo;slow&rdquo; – there&rsquo;s a significant overhead on executing every single instruction programmatically. This may be acceptable for older hardware, but not so much for the state of the art (and video games have always been one of the most demanding types of applications). The second reason is that there&rsquo;s no need! Linux/macOS are perfectly capable of running Windows binaries <em>natively</em>, they just need a little push&mldr;</p><p>Let&rsquo;s compile a simple program for both Linux and Windows and compare the results:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>int</span> <span style=color:#000>foo</span>(<span style=color:#a90d91>int</span> <span style=color:#000>x</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#000>x</span> <span style=color:#000>*</span> <span style=color:#000>x</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>int</span> <span style=color:#000>main</span>(<span style=color:#a90d91>int</span> <span style=color:#000>argc</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a90d91>int</span> <span style=color:#000>code</span> <span style=color:#000>=</span> <span style=color:#000>foo</span>(<span style=color:#000>argc</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#000>code</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=2.png alt=image width=2628 height=1152>
(left – Linux, right – Windows)</p><p>The results are visibly different, but the instruction set is actually the same: <code>push</code>, <code>pop</code>, <code>mov</code>, <code>add</code>, <code>sub</code>, <code>imul</code>, <code>ret</code>. So if we had an &ldquo;emulator&rdquo; that can execute these instructions, theoretically it should be able to execute both. And turns out that we do have it – that&rsquo;s our CPU.</p><h2 id=how-linux-runs-a-binary>How Linux runs a binary
<a class=heading-link href=#how-linux-runs-a-binary>#</a></h2><p>Before running a Windows binary on Linux, let’s figure out how to run a normal Linux binary.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>❯ cat app.cc
</span></span><span style=display:flex><span><span style=color:#177500>#include &lt;stdio.h&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int main<span style=color:#000>()</span> <span style=color:#000>{</span>
</span></span><span style=display:flex><span>  printf<span style=color:#000>(</span><span style=color:#c41a16>&#34;Hello!\n&#34;</span><span style=color:#000>)</span>;
</span></span><span style=display:flex><span>  <span style=color:#a90d91>return</span> 0;
</span></span><span style=display:flex><span><span style=color:#000>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>❯ clang app.cc -o app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>❯ ./app
</span></span><span style=display:flex><span>Hello!  <span style=color:#177500># works!</span>
</span></span></code></pre></div><p>Simple enough, let’s go a bit deeper. What happens when we do <code>./app</code>?</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>❯ ldd app
</span></span><span style=display:flex><span>        linux-vdso.so.1 <span style=color:#000>(</span>0x00007ffddc586000<span style=color:#000>)</span>
</span></span><span style=display:flex><span>        libc.so.6 <span style=color:#000>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style=color:#000>(</span>0x00007f743fcdc000<span style=color:#000>)</span>
</span></span><span style=display:flex><span>        /lib64/ld-linux-x86-64.so.2 <span style=color:#000>(</span>0x00007f743fed3000<span style=color:#000>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>❯ readelf -l app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Elf file <span style=color:#a90d91>type</span> is DYN <span style=color:#000>(</span>Position-Independent Executable file<span style=color:#000>)</span>
</span></span><span style=display:flex><span>Entry point 0x1050
</span></span><span style=display:flex><span>There are <span style=color:#1c01ce>13</span> program headers, starting at offset <span style=color:#1c01ce>64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Program Headers:
</span></span><span style=display:flex><span>  Type           Offset             VirtAddr           PhysAddr
</span></span><span style=display:flex><span>                 FileSiz            MemSiz              Flags  Align
</span></span><span style=display:flex><span>  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
</span></span><span style=display:flex><span>                 0x00000000000002d8 0x00000000000002d8  R      0x8
</span></span><span style=display:flex><span>  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
</span></span><span style=display:flex><span>                 0x000000000000001c 0x000000000000001c  R      0x1
</span></span><span style=display:flex><span>      <span style=color:#000>[</span>Requesting program interpreter: /lib64/ld-linux-x86-64.so.2<span style=color:#000>]</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>First of all, we see that the <code>app</code> is a dynamic executable. This means that it depends on some dynamic libraries and requires them to be present in runtime to be able to run. Another interesting thing here is the &ldquo;requesting program interpreter&rdquo; part. What&rsquo;s an interpreter doing here? I thought C++ was a compiled language, unlike Python&mldr;</p><p>In this context the interpreter is the &ldquo;dynamic loader&rdquo;. It&rsquo;s a special program that bootstraps the execution of the original program: it resolves and loads its dependencies and then gives over the control.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>❯ ./app
</span></span><span style=display:flex><span>Hello!  <span style=color:#177500># This works!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>❯ /lib64/ld-linux-x86-64.so.2 ./app
</span></span><span style=display:flex><span>Hello!  <span style=color:#177500># This works too!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500># Homework exercise, run this and try to make sense of the output.</span>
</span></span><span style=display:flex><span>❯ <span style=color:#000>LD_DEBUG</span><span style=color:#000>=</span>all /lib64/ld-linux-x86-64.so.2 ./app
</span></span></code></pre></div><p>When running the executable, the Linux kernel detects that it&rsquo;s dynamic and requires a loader. Then it executes the loader, which does all the work. We can verify that by running the program under the debugger, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>❯ lldb ./app
</span></span><span style=display:flex><span><span style=color:#000>(</span>lldb<span style=color:#000>)</span> target create <span style=color:#c41a16>&#34;./app&#34;</span>
</span></span><span style=display:flex><span>Current executable <span style=color:#a90d91>set</span> to <span style=color:#c41a16>&#39;/home/werat/src/cpp/app&#39;</span> <span style=color:#000>(</span>x86_64<span style=color:#000>)</span>.
</span></span><span style=display:flex><span><span style=color:#000>(</span>lldb<span style=color:#000>)</span> process launch --stop-at-entry
</span></span><span style=display:flex><span>Process <span style=color:#1c01ce>351228</span> stopped
</span></span><span style=display:flex><span>* thread <span style=color:#177500>#1, name = &#39;app&#39;, stop reason = signal SIGSTOP</span>
</span></span><span style=display:flex><span>    frame <span style=color:#177500>#0: 0x00007ffff7fcd050 ld-2.33.so`_start</span>
</span></span><span style=display:flex><span>ld-2.33.so<span style=color:#c41a16>`</span>_start:
</span></span><span style=display:flex><span>    0x7ffff7fcd050 &lt;+0&gt;: movq   %rsp, %rdi
</span></span><span style=display:flex><span>    0x7ffff7fcd053 &lt;+3&gt;: callq  0x7ffff7fcdd70            ; _dl_start at rtld.c:503:1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ld-2.33.so<span style=color:#c41a16>`</span>_dl_start_user:
</span></span><span style=display:flex><span>    0x7ffff7fcd058 &lt;+0&gt;: movq   %rax, %r12
</span></span><span style=display:flex><span>    0x7ffff7fcd05b &lt;+3&gt;: movl   0x2ec57<span style=color:#000>(</span>%rip<span style=color:#000>)</span>, %eax       ; _dl_skip_args
</span></span><span style=display:flex><span>Process <span style=color:#1c01ce>351228</span> launched: <span style=color:#c41a16>&#39;/home/werat/src/cpp/app&#39;</span> <span style=color:#000>(</span>x86_64<span style=color:#000>)</span>
</span></span></code></pre></div><p>Here we can see that the first instruction executed is in <code>ld-2.33.so</code>, <em>not</em> the <code>app</code> binary.</p><p>To summarize, the process of running a dynamically linked executable on Linux looks roughly like this:</p><ul><li>Kernel loads the image (≈ binary) and sees it&rsquo;s a dynamic executable</li><li>Kernel loads the dynamic loader (<code>ld.so</code>) and gives it control</li><li>The dynamic loader resolves the dependencies and loads them</li><li>The dynamic loader gives the control back to the original binary</li><li>The original binary starts execution in <code>_start()</code> and eventually gets to <code>main()</code></li></ul><p>At this point it&rsquo;s pretty clear why simply running a Windows executable won&rsquo;t work – it has different format and the kernel simply doesn&rsquo;t know what to do with it:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>❯ ./HalfLife4.exe
</span></span><span style=display:flex><span>-bash: HalfLife4.exe: cannot execute binary file: Exec format error
</span></span></code></pre></div><p>However, if we could get past the steps 1-4 and somehow get to 5, it should work in theory, right? Since we&rsquo;re talking about &ldquo;execution&rdquo;, what does it mean, from the OS perspective, to &ldquo;run&rdquo; the binary?</p><p>Every executable has the <code>.text</code> section, which contains the serialized CPU instructions:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>❯ objdump -drS app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app:     file format elf64-x86-64
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Disassembly of section .text:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#1c01ce>0000000000001050</span> &lt;_start&gt;:
</span></span><span style=display:flex><span>    1050:       <span style=color:#1c01ce>31</span> ed                   xor    %ebp,%ebp
</span></span><span style=display:flex><span>    1052:       <span style=color:#1c01ce>49</span> <span style=color:#1c01ce>89</span> d1                mov    %rdx,%r9
</span></span><span style=display:flex><span>    1055:       5e                      pop    %rsi
</span></span><span style=display:flex><span>    1056:       <span style=color:#1c01ce>48</span> <span style=color:#1c01ce>89</span> e2                mov    %rsp,%rdx
</span></span><span style=display:flex><span>    1059:       <span style=color:#1c01ce>48</span> <span style=color:#1c01ce>83</span> e4 f0             and    <span style=color:#000>$0</span>xfffffffffffffff0,%rsp
</span></span><span style=display:flex><span>    105d:       <span style=color:#1c01ce>50</span>                      push   %rax
</span></span><span style=display:flex><span>    105e:       <span style=color:#1c01ce>54</span>                      push   %rsp
</span></span><span style=display:flex><span>    105f:       4c 8d <span style=color:#1c01ce>05</span> 6a <span style=color:#1c01ce>01</span> <span style=color:#1c01ce>00</span> <span style=color:#1c01ce>00</span>    lea    0x16a<span style=color:#000>(</span>%rip<span style=color:#000>)</span>,%r8        <span style=color:#177500># 11d0 &lt;__libc_csu_fini&gt;</span>
</span></span><span style=display:flex><span>    1066:       <span style=color:#1c01ce>48</span> 8d 0d <span style=color:#1c01ce>03</span> <span style=color:#1c01ce>01</span> <span style=color:#1c01ce>00</span> <span style=color:#1c01ce>00</span>    lea    0x103<span style=color:#000>(</span>%rip<span style=color:#000>)</span>,%rcx        <span style=color:#177500># 1170 &lt;__libc_csu_init&gt;</span>
</span></span><span style=display:flex><span>    106d:       <span style=color:#1c01ce>48</span> 8d 3d cc <span style=color:#1c01ce>00</span> <span style=color:#1c01ce>00</span> <span style=color:#1c01ce>00</span>    lea    0xcc<span style=color:#000>(</span>%rip<span style=color:#000>)</span>,%rdi        <span style=color:#177500># 1140 &lt;main&gt;</span>
</span></span><span style=display:flex><span>    1074:       ff <span style=color:#1c01ce>15</span> 4e 2f <span style=color:#1c01ce>00</span> <span style=color:#1c01ce>00</span>       call   *0x2f4e<span style=color:#000>(</span>%rip<span style=color:#000>)</span>        <span style=color:#177500># 3fc8 &lt;__libc_start_main@GLIBC_2.2.5&gt;</span>
</span></span><span style=display:flex><span>    107a:       f4                      hlt
</span></span><span style=display:flex><span>    107b:       0f 1f <span style=color:#1c01ce>44</span> <span style=color:#1c01ce>00</span> <span style=color:#1c01ce>00</span>          nopl   0x0<span style=color:#000>(</span>%rax,%rax,1<span style=color:#000>)</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>In order to &ldquo;run&rdquo; the executable the operating system loads the binary into memory (specifically the <code>.text</code> section), sets the current instruction pointer to an address where the code is located and that&rsquo;s it, the executable is running. Can we do the same for Windows executables?</p><p>Yes! The code inside the executables is &ldquo;portable&rdquo; between Windows and Linux (assuming the same CPU architecture). If we just take the code out of the Windows executable, load it in memory and point <code>%rip</code> to the right place – the processor will happily execute it!</p><p><img src=3.jpg alt="code is code!" width=1130 height=534 style=width:100%;max-width:700px></p><h2 id=hello-wine>Hello, Wine!
<a class=heading-link href=#hello-wine>#</a></h2><p>Essentially, <code>wine</code> is a &ldquo;dynamic loader&rdquo; for Windows executables. It&rsquo;s a native Linux binary, hence it can just run normally, and it knows how to deal with EXE and DLLs. It&rsquo;s kinda an equivalent of <code>ld-linux-x86-64.so.2</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#177500># running an ELF binary</span>
</span></span><span style=display:flex><span>❯ /lib64/ld-linux-x86-64.so.2 ./app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500># running a PE binary</span>
</span></span><span style=display:flex><span>❯ wine64 HalfLife4.exe
</span></span></code></pre></div><p><code>wine</code> loads the Windows executable into memory, parses it, figures out the dependencies, figures out where the executable code is (i.e. the <code>.text</code> section) and then finally jumps into that code.</p><blockquote><p>Well, in reality it jumps into something like <code>ntdll.dll!RtlUserThreadStart()</code>, which is the &ldquo;user-space&rdquo; entry point in the Windows world. It will eventually get to <code>mainCRTStartup()</code> (the equivalent of <code>_start</code>) and then finally to the actual <code>main()</code>.</p></blockquote><p>At this point our Linux system is executing the code originally compiled for Windows and everything seems to work. Except&mldr;</p><h2 id=system-calls>System calls
<a class=heading-link href=#system-calls>#</a></h2><p>System calls, or syscalls for short, is what makes Wine so complicated. <strong>Syscall</strong> is a call of a function that is implemented in the operating system (hence, <em>system</em> call), not in the application binary or any of its dynamic libraries. The set of syscalls provided by the OS is essentially the operating system API.</p><p>Examples on Linux: <code>read</code>, <code>write</code>, <code>open</code>, <code>brk</code>, <code>getpid</code></p><p>Examples on Windows: <code>NtReadFile</code>, <code>NtCreateProcess</code>, <a href="http://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FMutant%2FNtCreateMutant.html"><code>NtCreateMutant</code></a> 😱</p><p>System calls are not regular function calls in the code. Opening a file, for example, must be performed by the kernel itself, since it&rsquo;s the one keeping track of the file descriptors. Therefore the application code needs a way to &ldquo;interrupt&rdquo; itself and give control to the kernel (this operation is typically called <a href=https://en.wikipedia.org/wiki/Context_switch>context switch</a>).</p><p>The set of functions exposed by the operating system and the way they should be called are different on every operating system. On Linux, for example, in order to call <code>read()</code> the binary would put the file descriptor into the register <code>%rdi</code>, the buffer pointer to <code>%rsi</code> and the number of bytes to read to <code>%rdx</code>. On Windows, however, there&rsquo;s no <code>read()</code> function in the kernel! Neither the arguments would make any sense. Therefore the binary compiled for Windows will use the Windows-way of doing syscalls, which will not work on Linux as is. I won&rsquo;t go deep into how exactly syscalls work, here&rsquo;s a great article about the Linux implementation – <a href=https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/>https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/</a>.</p><p>Let&rsquo;s compile another small program and compare the generated code on Linux and Windows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#633820>#include</span> <span style=color:#633820>&lt;stdio.h&gt;</span><span style=color:#633820>
</span></span></span><span style=display:flex><span><span style=color:#633820></span>
</span></span><span style=display:flex><span><span style=color:#a90d91>int</span> <span style=color:#000>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#000>printf</span>(<span style=color:#c41a16>&#34;Hello!</span><span style=color:#c41a16>\n</span><span style=color:#c41a16>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a90d91>return</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=4.png alt=image width=2526 height=784>
(left – Linux, right – Windows)</p><p>This time we&rsquo;re calling a function from the standard library, which, in turn, eventually performs a system call. On the screenshot above the Linux version calls <code>puts</code> and the Windows one – <code>printf</code>. These functions are coming from the standard library (<code>libc.so</code> on Linux, <code>ucrtbase.dll</code> on Windows), which the application uses to simplify the communication with the kernel. On Linux it&rsquo;s fairly common these days to build statically linked binaries, which don&rsquo;t depend on any dynamic libraries. In that case, the implementation of <code>puts</code> is embedded into the binary and no <code>libc.so</code> is involved in runtime.</p><p>On Windows, at least until not so long ago, &ldquo;only malware used direct system calls&rdquo;<sup>[citation needed]</sup>. Normal applications always depend on <code>kernel32.dll/kernelbase.dll/ntdll.dll</code>, which hide the low level magic of communicating with the kernel. The application just calls a function and the libraries take care of the rest:</p><p><img src=5.png alt=image width=750 height=261></p><p>(credit <a href=https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/>https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/</a>)</p><p>At this point you probably already have a feeling of what we&rsquo;re going to do next 😏</p><h2 id=runtime-translation-of-syscalls>Runtime translation of syscalls
<a class=heading-link href=#runtime-translation-of-syscalls>#</a></h2><p>What if we could &ldquo;intercept&rdquo; a syscall? Like, whenever the application calls <code>NtWriteFile()</code>, we would get in between, call <code>write()</code> instead and return the result in a format the binary expects. That should work. The quick and dirty solution for the example above might look something like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#177500>// HelloWorld.exe
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>lea</span>     <span style=color:#000>rcx</span>, <span style=color:#000>OFFSET</span> <span style=color:#000>FLAT</span>:<span style=color:#000>`</span><span style=color:#000>string</span><span style=color:#000>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#000>call</span>    <span style=color:#000>printf</span>
</span></span><span style=display:flex><span>  <span style=color:#000>↓↓</span>
</span></span><span style=display:flex><span><span style=color:#177500>// &#34;Fake&#34; ucrtbase.dll
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>mov</span> <span style=color:#000>edi</span>, <span style=color:#000>rcx</span>   <span style=color:#177500>// Convert the arguments to Linux ABI
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>call</span> <span style=color:#000>puts@PLT</span>  <span style=color:#177500>// Call the real Linux implementation
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#000>↓↓</span>
</span></span><span style=display:flex><span><span style=color:#177500>// Real libc.so
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>mov</span> <span style=color:#000>rdi</span>, <span style=color:#000>&lt;</span><span style=color:#000>stdout</span><span style=color:#000>&gt;</span>  <span style=color:#177500>// write to STDOUT
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>mov</span> <span style=color:#000>rsi</span>, <span style=color:#000>edi</span>       <span style=color:#177500>// pointer to &#34;Hello&#34;
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>mov</span> <span style=color:#000>rdx</span>, <span style=color:#1c01ce>5</span>         <span style=color:#177500>// how many chars to write
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>syscall</span>
</span></span></code></pre></div><p>We can provide a custom version of <code>ucrtbase.dll</code> which would have a special implementation of <code>printf</code>. Instead of trying to call the Windows kernel, it would follow the Linux ABI and call the <code>write</code> function from <code>libc.so</code>. In practice, however, the application can link against <code>ucrtbase.dll</code> statically and we can&rsquo;t modify the code of the binary for a number of reasons – it&rsquo;s messy and complicated, it messes with the DRM, etc.</p><p>So instead we would modify the place that stands in between the binary and the kernel – <code>ntdll.dll</code>. This is the &ldquo;gateway&rdquo; into the kernel and Wine indeed provides its <a href=https://github.com/wine-mirror/wine/tree/3602c676dadf823a4868b0b72f326159cb93766e/dlls/ntdll>custom implementation</a>. In the recent versions of Wine it consists of two parts: <code>ntdll.dll</code> (which is a PE library) and <code>ntdll.so</code> (which is an ELF library). The first one is a thin layer that just redirects the calls into the ELF counterpart. The ELF counterpart contains a special function called <code>__wine_syscall_dispatcher</code>, which <a href=https://github.com/wine-mirror/wine/blob/1d178982ae5a73b18f367026c8689b56789c39fd/dlls/ntdll/unix/signal_x86_64.c#L3142>performs a magic trick</a> of converting the current stack from Windows to Linux and back.</p><p>Therefore, when doing a syscall the call stack of the process running with Wine looks like this:</p><p><img src=6.png alt="call stack of process running with Wine" width=871 height=617 style=width:100%;max-width:697px></p><p>The syscall dispatcher is a bridge between the Windows world and the Linux world. It takes care of the calling conventions &ndash; allocates some stack space, moves the registers around, etc. Once the execution is in the Linux library (<code>ntdll.so</code>), we&rsquo;re free to use any regular Linux APIs (e.g. libc or syscall) and can actually read/write files, lock/unlock mutexes and so on.</p><h2 id=is-that-it>Is that it?
<a class=heading-link href=#is-that-it>#</a></h2><p>It sounds almost <em>too easy</em>. And it would be. First of all, there are a LOT of Windows APIs. And they&rsquo;re poorly documented and have known (and unknown haha) bugs, which must be preserved exactly as is. Most of the Wine source code is the implementation of various Windows DLLs.</p><p>Second, there are different ways to perform syscalls. Technically nothing prevents the application to do a direct system call via the <code>syscall</code> instruction and ideally this should work too (remember, Windows games do all kinds of crazy things). Linux kernel has a <a href=https://lwn.net/Articles/824380/>special mechanism</a> to handle this and of course it only adds complexity.</p><p>Third, there&rsquo;s this whole 32-bit vs 64-bit nonsense. There are a lot of old 32-bit games, which are never going to be re-released as 64-bit. Wine has support for both and again, this adds up to the overall complexity of the system.</p><p>Fourth, I didn’t even mention <code>wine-server</code> – a separate process spawned by Wine, which maintains the kernel “state” (open file descriptors, mutexes, etc).</p><p>Fifth, oh, did you want to run a game? Not just a hello world? Then you need to deal with DirectX, audio (hello PulseAudio, my old friend), input devices (gamepads, joysticks), etc. It’s a lot of work!</p><p>Wine has been in development for many years and came a long way. Today you can run the latest games like Cyberpunk 2077 or Elden Ring without any issues. Damn, sometimes Wine has even better performance compared to Windows! What a time to be alive&mldr;</p><hr><p>I hope this article gave you a basic idea of how Wine works. As I warned in the disclaimer, I’ve simplified a bunch of things and I may be wrong about some details (hopefully not too much). If you see that I&rsquo;m outright misleading people, please reach out and correct me!</p><hr><p>Discuss this article on <a href=https://lobste.rs/s/7f8exp/how_wine_works_101>lobste.rs</a> or <a href="https://news.ycombinator.com/item?id=33156727">HackerNews</a> or Reddit (<a href=https://www.reddit.com/r/linux_gaming/comments/y0ts39/how_wine_works_101/>r/Linux_Gaming</a>, <a href=https://www.reddit.com/r/programming/comments/y0tbuf/how_wine_works_101/>r/programming</a>)</p><p>Unofficial translations:</p><ul><li>Russian &ndash; <a href=https://habr.com/ru/company/dcmiran/blog/693842/>https://habr.com/ru/company/dcmiran/blog/693842/</a></li><li>Chinese &ndash; <a href=https://www.freebuf.com/articles/system/346955.html>https://www.freebuf.com/articles/system/346955.html</a></li></ul><hr></article></main><footer>© 2017 - 2023 Andy Hippo
· Licensed under <a href=https://github.com/werat/werat.github.io/blob/main/LICENSE>MIT</a></footer><script data-goatcounter=https://werat-dev.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>