<!doctype html><html lang=en><head><title>Segmented stacks in Wine/Proton minidumps | Andy Hippo</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Andy Hippo"><meta name=description content="


Last year I was working on improving debugging experience for Wine/Proton and part of that work went into supporting process crashdumps. Supporting minidumps was particularly important and of course it turned out things were broken. I worked on this problem more than a year ago and things may have changed since then. This article is a reconstruction of my old notes since I find the story is quite entertaining even if it&rsquo;s not so relevant today."><meta name=keywords content="blog,developer,personal,wine,proton,debugging,minidump,coredump,visual-studio,lldb"><link rel=me href=https://mastodon.social/@werat><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://werat.dev/blog/segmented-stacks-in-wine-proton-minidumps/shiba-wine-stack.png"><meta name=twitter:title content="Segmented stacks in Wine/Proton minidumps"><meta name=twitter:description content="


Last year I was working on improving debugging experience for Wine/Proton and part of that work went into supporting process crashdumps. Supporting minidumps was particularly important and of course it turned out things were broken. I worked on this problem more than a year ago and things may have changed since then. This article is a reconstruction of my old notes since I find the story is quite entertaining even if it&rsquo;s not so relevant today."><meta property="og:title" content="Segmented stacks in Wine/Proton minidumps"><meta property="og:description" content="


Last year I was working on improving debugging experience for Wine/Proton and part of that work went into supporting process crashdumps. Supporting minidumps was particularly important and of course it turned out things were broken. I worked on this problem more than a year ago and things may have changed since then. This article is a reconstruction of my old notes since I find the story is quite entertaining even if it&rsquo;s not so relevant today."><meta property="og:type" content="article"><meta property="og:url" content="https://werat.dev/blog/segmented-stacks-in-wine-proton-minidumps/"><meta property="og:image" content="https://werat.dev/blog/segmented-stacks-in-wine-proton-minidumps/shiba-wine-stack.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-18T12:00:00+02:00"><meta property="article:modified_time" content="2023-09-18T12:00:00+02:00"><link rel=canonical href=https://werat.dev/blog/segmented-stacks-in-wine-proton-minidumps/><link rel=alternate type=application/rss+xml title=werat.dev href=https://werat.dev/index.xml><link rel=icon href=/favicon.ico sizes=any><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=manifest href=/manifest.webmanifest><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.118.2"></head><body><header class=nav-header><nav><span class=nav-title><a href=/>werat.dev</a></span>
<a href=/about/>About</a>
<a href=/posts/>Blog</a>
<a href=/talks/>Talks</a></nav></header><main><article><header><h1 class=title>Segmented stacks in Wine/Proton minidumps</h1><time class=posted-on datetime=2023-09-18T12:00:00+02:00>September 18, 2023</time></header><p><img src=shiba-wine-stack.png alt="Shiba looking at a segmented stack of wine" width=1024 height=1024 style=width:100%;max-width:400px></p><p>Last year I was working on improving debugging experience for Wine/Proton and part of that work went into supporting process crashdumps. Supporting minidumps was particularly important and of course it turned out things were broken. I worked on this problem more than a year ago and things may have changed since then. This article is a reconstruction of my old notes since I find the story is quite entertaining even if it&rsquo;s not so relevant today.</p><hr><p><a href=https://docs.sentry.io/platforms/native/guides/minidumps/>Minidump</a> is a binary format that contains the information about the crashed process. It&rsquo;s much smaller than a full coredump, but has enough information to reconstruct the call stacks of all threads. Native Windows applications, when run with Wine/Proton, are running as &ldquo;real&rdquo; Linux processes and thus can produce valid core/minidumps upon crash. Or <em>could</em>, before Wine 7 happened.</p><p>Wine 7+ has changed the way it transitions into the native Linux code – the thread performing a syscall now has a segmented stack: the user-space part (i.e. Windows code) and kernel-space part (i.e. Linux). These two parts are located in different locations in memory and &ldquo;connected&rdquo; via a special function called <code>__wine_syscall_dispatcher</code> (which is written in pure assembly and doesn&rsquo;t have the CFI information). This causes a problem for tools that reconstruct call stacks. The solution for stack unwind was introduced in <a href=https://gitlab.winehq.org/wine/wine/-/merge_requests/1065>https://gitlab.winehq.org/wine/wine/-/merge_requests/1065</a>, however minidumps still have a problem – due to the way they are created, they&rsquo;re missing the memory of the user-space (i.e. Windows) part of the stack.</p><p>In out setup the minidumps were created via the <code>linux_core2md</code> tool, which is a part of the <a href=https://chromium.googlesource.com/breakpad/breakpad/>Breakpad</a> project. This tool takes a full core dump as a parameter and converts it to the minidump format. The relevant detail for us is how it saves the thread stack memory. The process is quite simple: get the current value of the stack pointer (<a href=https://chromium.googlesource.com/breakpad/breakpad/+/master/src/client/linux/minidump_writer/minidump_writer.cc#418>src</a>), move the pointer to the bottom of the page and save the 32kb of memory (<a href=https://chromium.googlesource.com/breakpad/breakpad/+/master/src/client/linux/minidump_writer/linux_dumper.cc#759>src</a>). The algorithm intentionally doesn&rsquo;t involve unwinding the stack, because that&rsquo;s a very heavy and unreliable process (which depends on having symbols, non-corrupted stack, etc). In most cases it works reasonably well, however it falls short when the stack is segmented. Which is exactly the case with Wine/Proton when a syscall is happening (which is also the case when the process is crashing by calling <code>abort()</code>).</p><p>In order to make minidumps useful again, we need to solve several problems:</p><ol><li>When writing the minidump, find the location of the second part of the stack.</li><li>Write it somewhere in the minidump in a way that other tools (e.g. the debugger) can understand it (i.e. it must be conforming to the minidump format).</li><li>Adjust the tools (e.g. the debugger, breakpad/crashpad processors) to handle the segmented stack when processing the dump and reconstructing the call stack.</li></ol><p>You can find the patch to Breakpad implementing the solution in the Appendix of the article. It wasn&rsquo;t merged upstream for understandable reasons (Breakpad itself is no longer actively developed and the solution is just way to hacky), but that&rsquo;s the beauty of open-source &ndash; just hack whatever you want it build it yourself!</p><h2 id=finding-the-user-space-stack-in-the-coredump>Finding the user-space stack in the coredump</h2><p>Unfortunately I didn&rsquo;t find a 100% reliable way to find the location of the user-space stack. The best way so far boils down to scanning the current (kernel-space) stack to locate the <code>syscall_frame</code> structure and then reading its <code>rsp</code> field, which points to the user-space stack. This works reasonably well, but locating <code>syscall_frame</code> is quite tricky.</p><p>We know that the <code>syscall_frame</code> struct is located at the top of the kernel-space stack (<a href="https://gitlab.winehq.org/wine/wine/-/blob/master/dlls/ntdll/unix/signal_x86_64.c?ref_type=heads#L2354">src</a>). However, we don&rsquo;t know where the top of the stack is. We also know that the kernel stack basically &ldquo;starts&rdquo; with <code>__wine_syscall_dispatcher</code> performing a function call via the <code>call</code> instruction (<a href="https://gitlab.winehq.org/wine/wine/-/blob/master/dlls/ntdll/unix/signal_x86_64.c?ref_type=heads#L2701">src</a>). Syscall dispatcher follows the x64 ABI calling convention, so it also allocates 32-byte the shadow space before executing a <code>call</code>. This means the stack layout looks like this:</p><p><img src=stack-layout.png alt="Stack layout" width=1128 height=1198 style=width:100%;max-width:500px></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>sizeof</span>(<span style=color:#a90d91>struct</span> <span style=color:#3f6e75>syscall_frame</span>) <span style=color:#000>==</span> <span style=color:#1c01ce>0x400</span>;
</span></span><span style=display:flex><span><span style=color:#000>offsetof</span>(<span style=color:#a90d91>struct</span> <span style=color:#3f6e75>syscall_frame</span>, <span style=color:#000>rsp</span>) <span style=color:#000>==</span> <span style=color:#1c01ce>0x88</span>;
</span></span></code></pre></div><p>The value of the &ldquo;return address&rdquo; is the address of <code>__wine_syscall_dispatcher</code> + some offset into it (since the return address points to the location after the <code>call</code> instruction inside the function). Luckily, the address of <code>__wine_syscall_dispatcher</code> is saved at a fixed offset in memory (<a href="https://gitlab.winehq.org/wine/wine/-/blob/master/dlls/ntdll/unix/signal_x86_64.c?ref_type=heads#L2356">src</a>):</p><p><img src=vs1.png alt="Memory view" width=551 height=129 style=width:100%;max-width:500px>
<img src=vs2.png alt="Disassembly view" width=506 height=138 style=width:100%;max-width:500px></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#1c01ce>0x7ffe1000</span> <span style=color:#000>=</span> (<span style=color:#000>address</span> <span style=color:#000>of</span> <span style=color:#000>KSHARED_USER_DATA</span>) <span style=color:#000>+</span> <span style=color:#000>PAGE_SIZE</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0x7ffe0000</span> <span style=color:#000>+</span> <span style=color:#1c01ce>0x1000</span>;
</span></span></code></pre></div><p>So in order to locate the <code>syscall_frame</code> struct, we can first get the address of <code>__wine_syscall_dispatcher</code> by reading <code>0x7ffe1000</code> and then scan the stack looking for something that looks like the return address to it. Once we found it, skip additional 32 bytes (shadow space) and we&rsquo;re at the beginning of the <code>syscall_frame</code>! Now skip another 126 bytes (0x88, <a href="https://gitlab.winehq.org/wine/wine/-/blob/master/dlls/ntdll/unix/signal_x86_64.c?ref_type=heads#L399">src</a>) to get to the <code>rsp</code> field.</p><p>Tl;dr algorithm for locating the user-space stack:</p><ol><li>Read <code>0x7ffe1000</code> to get the address of <code>__wine_syscall_dispatcher</code></li><li>Scan the stack and find the location of the return address to <code>__wine_syscall_dispatcher</code></li><li>Skip 4 + 136 bytes to get to the <code>syscall_frame.rsp</code></li><li>Read the value, it should point to the user-space stack!</li></ol><h3 id=alternative-1-unwind-via-frame-pointers>Alternative 1: unwind via frame pointers</h3><p>Another viable solution would be to manually unwind the stack by following the frame pointers until we hit the <code>__wine_syscall_dispatcher</code> boundary. This approach looks more resilient to changes in the layout of the <code>syscall_frame</code> and its location in the stack, however it also relies on having valid frame pointers, which may or may not be present in all libraries.</p><h3 id=alternative-2-allocate-kernel-stack-below-user-stack>Alternative 2: allocate kernel stack below user stack</h3><p>The problem wouldn&rsquo;t exist if the stack weren&rsquo;t segmented. There was a patch last year that seems to put the kernel stack right below the user stack, so that the memory is located nearby – <a href=https://www.winehq.org/pipermail/wine-devel/2021-September/196608.html>https://www.winehq.org/pipermail/wine-devel/2021-September/196608.html</a>.</p><p>I&rsquo;ve tried applying the patch locally, but it didn&rsquo;t seem to do what it claimed – the stacks for Windows and Linux parts of the stack were still located in different locations, so the minidumper didn&rsquo;t work. I haven&rsquo;t dug deeper into why the patch doesn&rsquo;t work, it&rsquo;s possible I missed something back then.</p><h2 id=writing-the-user-space-stack-into-the-minidump>Writing the user-space stack into the minidump</h2><p>Now that we&rsquo;ve found the second part of the stack, we need to save it into the minidump. The minidump stores the information about the threads in the <code>MINIDUMP_THREAD_LIST</code> stream, which consists of <code>MINIDUMP_THREAD</code> objects:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>typedef</span> <span style=color:#a90d91>struct</span> <span style=color:#3f6e75>_MINIDUMP_THREAD</span> {
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG32</span>                      <span style=color:#000>ThreadId</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG32</span>                      <span style=color:#000>SuspendCount</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG32</span>                      <span style=color:#000>PriorityClass</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG32</span>                      <span style=color:#000>Priority</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG64</span>                      <span style=color:#000>Teb</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>MINIDUMP_MEMORY_DESCRIPTOR</span>   <span style=color:#000>Stack</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>MINIDUMP_LOCATION_DESCRIPTOR</span> <span style=color:#000>ThreadContext</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Stack</code> field is a memory descriptor, which describes the chunk of memory that contains the thread stack. A memory descriptor is just some meta information + a pointer to the data in the minidump, and all memory descriptors are also saved in the <code>MINIDUMP_MEMORY_LIST</code> stream:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>typedef</span> <span style=color:#a90d91>struct</span> <span style=color:#3f6e75>_MINIDUMP_MEMORY_LIST</span> {
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG32</span>                    <span style=color:#000>NumberOfMemoryRanges</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>MINIDUMP_MEMORY_DESCRIPTOR</span> <span style=color:#000>MemoryRanges</span>[<span style=color:#1c01ce>0</span>];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a90d91>typedef</span> <span style=color:#a90d91>struct</span> <span style=color:#3f6e75>_MINIDUMP_MEMORY_DESCRIPTOR</span> {
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG64</span>                      <span style=color:#000>StartOfMemoryRange</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>MINIDUMP_LOCATION_DESCRIPTOR</span> <span style=color:#000>Memory</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a90d91>typedef</span> <span style=color:#a90d91>struct</span> <span style=color:#3f6e75>_MINIDUMP_LOCATION_DESCRIPTOR</span> {
</span></span><span style=display:flex><span>  <span style=color:#000>ULONG32</span> <span style=color:#000>DataSize</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>RVA</span>     <span style=color:#000>Rva</span>;  <span style=color:#177500>// Data offset from the beginning of the minidump file.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span></code></pre></div><p>The thread structure doesn&rsquo;t allow specifying multiple stack memory regions, but we can save any number of extra memory regions into the <code>MINIDUMP_MEMORY_LIST</code> stream. If we&rsquo;re lucky, the tools processing the minudump will be able to understand that. The difference in the layout will look roughly like this:</p><p><img src=before-after.png alt="Minidump layout before and after" width=1732 height=1508></p><h2 id=adjusting-the-tools-lldb>Adjusting the tools (LLDB)</h2><p>Luckily, the LLDB debugger can understand multiple stack segments and works out of the box! Here&rsquo;s an example of Stadia for Visual Studio debugging the minidump from a 64-bit process:</p><p><img src=vs-lldb.png alt="Visual Studio LLDB minidump" width=1549 height=1223></p><p>The call stack is correct and the debugger correctly recognizes that the source of the crash is the segmentation fault, which happened in the <code>foo_segfault()</code> function.</p><h2 id=wine-wow64-and-32-bit>Wine WOW64 and 32-bit</h2><p>For 32-bit processes the story is slightly different. First of all, <code>linux_core2md</code> only works for the coredumps of the same bitness! This means that to convert 64-bit coredumps you need to use a 64-bit version of <code>linux_core2md</code> and for 32-bit coredumps you need a 32-bit version of <code>linux_core2md</code>.</p><p>It doesn&rsquo;t seem to be possible to build a single version of <code>linux_core2md</code> capable of handling both 64-bit and 32-bit formats due the the nature of ELF APIs it depends on – most of the structs have build-time conditional sizes. For example, <code>ElfCoreDump</code> has the following definitions:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>class</span> <span style=color:#3f6e75>ElfCoreDump</span> {
</span></span><span style=display:flex><span> <span style=color:#a90d91>public</span><span style=color:#000>:</span>
</span></span><span style=display:flex><span>  <span style=color:#177500>// ELF types based on the native word size.
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>typedef</span> <span style=color:#000>ElfW</span>(<span style=color:#000>Ehdr</span>) <span style=color:#000>Ehdr</span>;
</span></span><span style=display:flex><span>  <span style=color:#000>…</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#633820>#if ULONG_MAX == 0xffffffff
</span></span></span><span style=display:flex><span><span style=color:#633820></span>  <span style=color:#a90d91>static</span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>int</span> <span style=color:#000>kClass</span> <span style=color:#000>=</span> <span style=color:#000>ELFCLASS32</span>;
</span></span><span style=display:flex><span><span style=color:#633820>#elif ULONG_MAX == 0xffffffffffffffff
</span></span></span><span style=display:flex><span><span style=color:#633820></span>  <span style=color:#a90d91>static</span> <span style=color:#a90d91>const</span> <span style=color:#a90d91>int</span> <span style=color:#000>kClass</span> <span style=color:#000>=</span> <span style=color:#000>ELFCLASS64</span>;
</span></span><span style=display:flex><span><span style=color:#633820>#else
</span></span></span><span style=display:flex><span><span style=color:#633820>#error &#34;Unsupported word size for ElfCoreDump.&#34;
</span></span></span><span style=display:flex><span><span style=color:#633820>#endif
</span></span></span></code></pre></div><p><code>ElfW</code> is defined as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#633820>#ifndef __ELF_NATIVE_CLASS
</span></span></span><span style=display:flex><span><span style=color:#633820>#  if defined(_M_X64) || defined(__x86_64) || defined(__amd64)
</span></span></span><span style=display:flex><span><span style=color:#633820>#    define __ELF_NATIVE_CLASS 64
</span></span></span><span style=display:flex><span><span style=color:#633820>#  else
</span></span></span><span style=display:flex><span><span style=color:#633820>#    define __ELF_NATIVE_CLASS 32
</span></span></span><span style=display:flex><span><span style=color:#633820>#  endif
</span></span></span><span style=display:flex><span><span style=color:#633820>#endif
</span></span></span><span style=display:flex><span><span style=color:#633820></span>
</span></span><span style=display:flex><span><span style=color:#633820>#define ElfW(type)        _ElfW (Elf, __ELF_NATIVE_CLASS, type)
</span></span></span><span style=display:flex><span><span style=color:#633820>#define _ElfW(e,w,t)        _ElfW_1 (e, w, _##t)
</span></span></span><span style=display:flex><span><span style=color:#633820>#define _ElfW_1(e,w,t)        e##w##t
</span></span></span></code></pre></div><p>Therefore, depending on the target architecture, <code>Ehdr</code> will be either <code>Elf32_Ehdr</code> or <code>Elf64_Ehdr</code>, which have <a href=https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-43405/index.html>different memory layouts</a>. Even worse, in some places the code converts raw pointers (e.g. <code>char*</code>) to <code>Elf32_Addr/Elf64_Addr</code>, which also have different sizes (4 and 8 bytes respectively). So the only reasonable way to solve this is to build <code>linux_core2md</code> in 32-bit mode 😢</p><h2 id=appendix>Appendix</h2><h3 id=exploring-the-minidump-in-imhex>Exploring the minidump in ImHex</h3><p>When debugging and trying to understand the minidump format, it might be useful to look at the data directly in the HEX editor. Just looking at the series of bytes is not fun, so I&rsquo;ve written a simple format description for <a href=https://github.com/WerWolv/ImHex>ImHex</a> – <a href=https://github.com/werat/imhex-minidump>https://github.com/werat/imhex-minidump</a>.</p><p>With the description loaded, the editor highlights different regions of the file according to the format definitions. It can also format strings and makes it much easier to understand how the data is laid out.</p><p><img src=imhex1.png alt="ImHex 2" width=552 height=658>
<img src=imhex2.png alt="Imhex 2" width=1151 height=705></p><h3 id=patch-to-breakpad-implementing-the-solution>Patch to Breakpad implementing the solution</h3><p>When maintaining private non-upstreamable patches, it&rsquo;s very important to keep them as conflict-free as possible. This makes upgrades much easier and keeps the maintainers happy. The parent for this patch is <a href=https://chromium.googlesource.com/breakpad/breakpad/+/0808030bee8bc88a34675cd1dd83b965a2249a08>https://chromium.googlesource.com/breakpad/breakpad/+/0808030bee8bc88a34675cd1dd83b965a2249a08</a>, although I&rsquo;m pretty sure it should apply to the current HEAD without any issues.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>---</span> <span style=color:#000>a</span><span style=color:#000>/</span><span style=color:#000>breakpad</span><span style=color:#000>/</span><span style=color:#000>src</span><span style=color:#000>/</span><span style=color:#000>client</span><span style=color:#000>/</span><span style=color:#000>linux</span><span style=color:#000>/</span><span style=color:#000>minidump_writer</span><span style=color:#000>/</span><span style=color:#000>minidump_writer</span>.<span style=color:#000>cc</span>
</span></span><span style=display:flex><span><span style=color:#000>+++</span> <span style=color:#000>b</span><span style=color:#000>/</span><span style=color:#000>breakpad</span><span style=color:#000>/</span><span style=color:#000>src</span><span style=color:#000>/</span><span style=color:#000>client</span><span style=color:#000>/</span><span style=color:#000>linux</span><span style=color:#000>/</span><span style=color:#000>minidump_writer</span><span style=color:#000>/</span><span style=color:#000>minidump_writer</span>.<span style=color:#000>cc</span>
</span></span><span style=display:flex><span><span style=color:#000>@@</span> <span style=color:#000>-</span><span style=color:#1c01ce>320</span>,<span style=color:#1c01ce>6</span> <span style=color:#000>+</span><span style=color:#1c01ce>320</span>,<span style=color:#1c01ce>92</span> <span style=color:#000>@@</span>
</span></span><span style=display:flex><span>     <span style=color:#a90d91>return</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>  <span style=color:#a90d91>bool</span> <span style=color:#000>IsWine64Process</span>() {
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#a90d91>for</span> (<span style=color:#a90d91>const</span> <span style=color:#000>MappingInfo</span><span style=color:#000>*</span> <span style=color:#000>mapping</span> : <span style=color:#000>dumper_</span><span style=color:#000>-&gt;</span><span style=color:#000>mappings</span>()) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>if</span> (<span style=color:#000>strstr</span>(<span style=color:#000>mapping</span><span style=color:#000>-&gt;</span><span style=color:#000>name</span>, <span style=color:#c41a16>&#34;/wine64-preloader&#34;</span>)) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>        <span style=color:#a90d91>return</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      }
</span></span><span style=display:flex><span><span style=color:#000>+</span>    }
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#a90d91>return</span> <span style=color:#a90d91>false</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>  }
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>  <span style=color:#a90d91>bool</span> <span style=color:#000>AddressBelongsTo</span>(<span style=color:#a90d91>uint64_t</span> <span style=color:#000>addr</span>, <span style=color:#a90d91>const</span> <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#000>module</span>) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#a90d91>for</span> (<span style=color:#a90d91>const</span> <span style=color:#000>MappingInfo</span><span style=color:#000>*</span> <span style=color:#000>mapping</span> : <span style=color:#000>dumper_</span><span style=color:#000>-&gt;</span><span style=color:#000>mappings</span>()) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>if</span> (<span style=color:#000>strstr</span>(<span style=color:#000>mapping</span><span style=color:#000>-&gt;</span><span style=color:#000>name</span>, <span style=color:#000>module</span>)) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>        <span style=color:#a90d91>return</span> <span style=color:#000>addr</span> <span style=color:#000>&gt;=</span> <span style=color:#000>mapping</span><span style=color:#000>-&gt;</span><span style=color:#000>system_mapping_info</span>.<span style=color:#000>start_addr</span> <span style=color:#000>&amp;&amp;</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>               <span style=color:#000>addr</span> <span style=color:#000>&lt;=</span> <span style=color:#000>mapping</span><span style=color:#000>-&gt;</span><span style=color:#000>system_mapping_info</span>.<span style=color:#000>end_addr</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      }
</span></span><span style=display:flex><span><span style=color:#000>+</span>    }
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#a90d91>return</span> <span style=color:#a90d91>false</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>  }
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>  <span style=color:#a90d91>void</span> <span style=color:#000>FillWindowsPartOfTheStack</span>(<span style=color:#a90d91>uint32_t</span> <span style=color:#000>tid</span>,
</span></span><span style=display:flex><span><span style=color:#000>+</span>                                 <span style=color:#a90d91>uint8_t</span><span style=color:#000>*</span> <span style=color:#000>linux_stack_ptr</span>,
</span></span><span style=display:flex><span><span style=color:#000>+</span>                                 <span style=color:#000>size_t</span> <span style=color:#000>stack_len</span>) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#177500>// In Wine 7 the size of the __wine_syscall_dispatcher is 643 (0x283) bytes.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#177500>// The return address should point inside the function, but give the offset
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#177500>// a little bit of leeway just in case.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#a90d91>constexpr</span> <span style=color:#a90d91>uint64_t</span> <span style=color:#000>kDispatcherMaxOffset</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0x320</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#177500>// First find out the address of __wine_syscall_dispatcher
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#a90d91>uint64_t</span> <span style=color:#000>dispatcher_addr</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#177500>// 0x7ffe1000 = &amp;KSHARED_USER_DATA + PAGE_SIZE = 0x7ffe0000 + 0x1000;
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>dumper_</span><span style=color:#000>-&gt;</span><span style=color:#000>CopyFromProcess</span>(<span style=color:#000>&amp;</span><span style=color:#000>dispatcher_addr</span>, <span style=color:#000>tid</span>,
</span></span><span style=display:flex><span><span style=color:#000>+</span>                                  (<span style=color:#a90d91>void</span><span style=color:#000>*</span>)<span style=color:#1c01ce>0x7ffe1000</span>, <span style=color:#1c01ce>8</span>)) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>return</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>    }
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#177500>// __wine_syscall_dispatcher should be defined in ntdll.so, verify that.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>AddressBelongsTo</span>(<span style=color:#000>dispatcher_addr</span>, <span style=color:#c41a16>&#34;/ntdll.so&#34;</span>)) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>return</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>    }
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>    <span style=color:#177500>// Now scan the stack looking for something that looks like return address
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#177500>// to the __wine_syscall_dispatcher.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>    <span style=color:#a90d91>for</span> (<span style=color:#a90d91>uint8_t</span><span style=color:#000>*</span> <span style=color:#000>p</span> <span style=color:#000>=</span> <span style=color:#000>linux_stack_ptr</span>; <span style=color:#000>p</span> <span style=color:#000>&lt;</span> <span style=color:#000>linux_stack_ptr</span> <span style=color:#000>+</span> <span style=color:#000>stack_len</span>; <span style=color:#000>++</span><span style=color:#000>p</span>) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// %rip should be `__wine_syscall_dispatcher+offset`.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#a90d91>uint64_t</span> <span style=color:#000>rip</span> <span style=color:#000>=</span> <span style=color:#000>*</span><span style=color:#a90d91>reinterpret_cast</span><span style=color:#000>&lt;</span><span style=color:#a90d91>uint64_t</span><span style=color:#000>*&gt;</span>(<span style=color:#000>p</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>if</span> (<span style=color:#000>rip</span> <span style=color:#000>-</span> <span style=color:#000>dispatcher_addr</span> <span style=color:#000>&gt;</span> <span style=color:#000>kDispatcherMaxOffset</span>) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>        <span style=color:#a90d91>continue</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      }
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// Found something that looks like a return address pointing into the
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#177500>// __wine_syscall_dispatcher(). Now skip some bytes to get to the
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#177500>// `syscall_frame` struct that contains the pointer to the Windows stack.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// Skip 8 bytes -- size of %rip.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#000>p</span> <span style=color:#000>+=</span> <span style=color:#1c01ce>8</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// Skip 32 bytes -- shadow space according to the x64 calling convention.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#000>p</span> <span style=color:#000>+=</span> <span style=color:#1c01ce>32</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// Skip 136 bytes to get to the syscall_frame-&gt;rsp:
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#177500>//   offsetof(struct syscall_frame, rsp) == 0x88
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#000>p</span> <span style=color:#000>+=</span> <span style=color:#1c01ce>136</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// Read the value of %rsp, this should point to the Windows stack.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#a90d91>uint64_t</span> <span style=color:#000>rsp</span> <span style=color:#000>=</span> <span style=color:#000>*</span><span style=color:#a90d91>reinterpret_cast</span><span style=color:#000>&lt;</span><span style=color:#a90d91>uint64_t</span><span style=color:#000>*&gt;</span>(<span style=color:#000>p</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// Copy the Windows stack as a separate memory region.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#a90d91>const</span> <span style=color:#a90d91>void</span><span style=color:#000>*</span> <span style=color:#000>stack_ptr</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#000>size_t</span> <span style=color:#000>len</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>dumper_</span><span style=color:#000>-&gt;</span><span style=color:#000>GetStackInfo</span>(<span style=color:#000>&amp;</span><span style=color:#000>stack_ptr</span>, <span style=color:#000>&amp;</span><span style=color:#000>len</span>, <span style=color:#000>rsp</span>)) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>        <span style=color:#a90d91>return</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      }
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>uint8_t</span><span style=color:#000>*</span> <span style=color:#000>stack_data</span> <span style=color:#000>=</span> <span style=color:#a90d91>reinterpret_cast</span><span style=color:#000>&lt;</span><span style=color:#a90d91>uint8_t</span><span style=color:#000>*&gt;</span>(<span style=color:#000>Alloc</span>(<span style=color:#000>len</span>));
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>dumper_</span><span style=color:#000>-&gt;</span><span style=color:#000>CopyFromProcess</span>(<span style=color:#000>stack_data</span>, <span style=color:#000>tid</span>, <span style=color:#000>stack_ptr</span>, <span style=color:#000>len</span>)) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>        <span style=color:#a90d91>return</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      }
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#000>MDMemoryDescriptor</span> <span style=color:#000>md</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#000>UntypedMDRVA</span> <span style=color:#000>memory</span>(<span style=color:#000>&amp;</span><span style=color:#000>minidump_writer_</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>if</span> (<span style=color:#000>!</span><span style=color:#000>memory</span>.<span style=color:#000>Allocate</span>(<span style=color:#000>len</span>))
</span></span><span style=display:flex><span><span style=color:#000>+</span>        <span style=color:#a90d91>return</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#000>memory</span>.<span style=color:#000>Copy</span>(<span style=color:#000>stack_data</span>, <span style=color:#000>len</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#000>md</span>.<span style=color:#000>start_of_memory_range</span> <span style=color:#000>=</span> <span style=color:#a90d91>reinterpret_cast</span><span style=color:#000>&lt;</span><span style=color:#000>uintptr_t</span><span style=color:#000>&gt;</span>(<span style=color:#000>stack_ptr</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#000>md</span>.<span style=color:#000>memory</span> <span style=color:#000>=</span> <span style=color:#000>memory</span>.<span style=color:#000>location</span>();
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#000>memory_blocks_</span>.<span style=color:#000>push_back</span>(<span style=color:#000>md</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#a90d91>break</span>;
</span></span><span style=display:flex><span><span style=color:#000>+</span>    }
</span></span><span style=display:flex><span><span style=color:#000>+</span>  }
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span>   <span style=color:#a90d91>bool</span> <span style=color:#000>FillThreadStack</span>(<span style=color:#000>MDRawThread</span><span style=color:#000>*</span> <span style=color:#a90d91>thread</span>, <span style=color:#000>uintptr_t</span> <span style=color:#000>stack_pointer</span>,
</span></span><span style=display:flex><span>                        <span style=color:#000>uintptr_t</span> <span style=color:#000>pc</span>, <span style=color:#a90d91>int</span> <span style=color:#000>max_stack_len</span>, <span style=color:#a90d91>uint8_t</span><span style=color:#000>**</span> <span style=color:#000>stack_copy</span>) {
</span></span><span style=display:flex><span>     <span style=color:#000>*</span><span style=color:#000>stack_copy</span> <span style=color:#000>=</span> <span style=color:#a90d91>NULL</span>;
</span></span><span style=display:flex><span><span style=color:#000>@@</span> <span style=color:#000>-</span><span style=color:#1c01ce>375</span>,<span style=color:#1c01ce>6</span> <span style=color:#000>+</span><span style=color:#1c01ce>461</span>,<span style=color:#1c01ce>11</span> <span style=color:#000>@@</span>
</span></span><span style=display:flex><span>       <span style=color:#a90d91>thread</span><span style=color:#000>-&gt;</span><span style=color:#000>stack</span>.<span style=color:#000>start_of_memory_range</span> <span style=color:#000>=</span> <span style=color:#a90d91>reinterpret_cast</span><span style=color:#000>&lt;</span><span style=color:#000>uintptr_t</span><span style=color:#000>&gt;</span>(<span style=color:#000>stack</span>);
</span></span><span style=display:flex><span>       <span style=color:#a90d91>thread</span><span style=color:#000>-&gt;</span><span style=color:#000>stack</span>.<span style=color:#000>memory</span> <span style=color:#000>=</span> <span style=color:#000>memory</span>.<span style=color:#000>location</span>();
</span></span><span style=display:flex><span>       <span style=color:#000>memory_blocks_</span>.<span style=color:#000>push_back</span>(<span style=color:#a90d91>thread</span><span style=color:#000>-&gt;</span><span style=color:#000>stack</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>
</span></span><span style=display:flex><span><span style=color:#000>+</span>      <span style=color:#177500>// Mega-hack for processes running with Wine 7+.
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>+</span>      <span style=color:#a90d91>if</span> (<span style=color:#000>IsWine64Process</span>()) {
</span></span><span style=display:flex><span><span style=color:#000>+</span>        <span style=color:#000>FillWindowsPartOfTheStack</span>(<span style=color:#a90d91>thread</span><span style=color:#000>-&gt;</span><span style=color:#000>thread_id</span>, <span style=color:#000>*</span><span style=color:#000>stack_copy</span>, <span style=color:#000>stack_len</span>);
</span></span><span style=display:flex><span><span style=color:#000>+</span>      }
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     <span style=color:#a90d91>return</span> <span style=color:#a90d91>true</span>;
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div></article></main><footer>© 2017 - 2023 <a href=mailto:weratt@gmail.com>Andy Hippo</a>
(<a href=https://twitter.com/werat>@werat</a>)
· Licensed under <a href=https://github.com/werat/werat.github.io/blob/main/LICENSE>MIT</a></footer><script data-goatcounter=https://werat-dev.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>