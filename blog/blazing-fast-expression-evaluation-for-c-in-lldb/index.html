<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Andy Hippo"><meta name=description content="Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like print/call in GDB or expr/p in LLDB. It is also used extensively by the IDEs to support typical UI workflows: Immediate Window, Watch Window, hovering over a variable, custom data visualizers (see NatVis), etc."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Blazing fast expression evaluation for C++ in LLDB"><meta name=twitter:description content="Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like print/call in GDB or expr/p in LLDB. It is also used extensively by the IDEs to support typical UI workflows: Immediate Window, Watch Window, hovering over a variable, custom data visualizers (see NatVis), etc."><meta property="og:title" content="Blazing fast expression evaluation for C++ in LLDB"><meta property="og:description" content="Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like print/call in GDB or expr/p in LLDB. It is also used extensively by the IDEs to support typical UI workflows: Immediate Window, Watch Window, hovering over a variable, custom data visualizers (see NatVis), etc."><meta property="og:type" content="article"><meta property="og:url" content="https://werat.dev/blog/blazing-fast-expression-evaluation-for-c-in-lldb/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-23T00:00:00+00:00"><title>Blazing fast expression evaluation for C++ in LLDB Â· Reboot and Shine</title><link rel=canonical href=https://werat.dev/blog/blazing-fast-expression-evaluation-for-c-in-lldb/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.1.7" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.eb7743f94930acfd17146aecc1f80e86fe35b3e451f2ec0c98485f9c4d962f34.css integrity="sha256-63dD+UkwrP0XFGrswfgOhv41s+RR8uwMmEhfnE2WLzQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.dde8a61eb31a32353b4baf3d9113f03c4ea2a8ca9bb736f59ca2d2b2cb664f0b.css integrity="sha256-3eimHrMaMjU7S689kRPwPE6iqMqbtzb1nKLSsstmTws=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/custom.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.82.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Reboot and Shine</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/talks/>Talks</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://werat.dev/blog/blazing-fast-expression-evaluation-for-c-in-lldb/>Blazing fast expression evaluation for C++ in LLDB</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-03-23T00:00:00Z>March 23, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
10-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<a href=/tags/lldb/>lldb</a>
<span class=separator>â€¢</span>
<a href=/tags/debugging/>debugging</a>
<span class=separator>â€¢</span>
<a href=/tags/open-source/>open-source</a>
<span class=separator>â€¢</span>
<a href=/tags/c++/>c++</a></div></div></header><div><p>Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like <code>print</code>/<code>call</code> in GDB or <code>expr</code>/<code>p</code> in LLDB. It is also used extensively by the IDEs to support typical UI workflows: <a href="https://docs.microsoft.com/en-us/visualstudio/ide/reference/immediate-window?view=vs-2019">Immediate Window</a>, <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/watch-and-quickwatch-windows?view=vs-2019">Watch Window</a>, hovering over a variable, custom data visualizers (see <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019">NatVis</a>), etc.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#f92672>*</span> <span style=color:#66d9ef>thread</span> <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>1</span>, queue <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>com.apple.main<span style=color:#f92672>-</span><span style=color:#66d9ef>thread</span><span style=color:#960050;background-color:#1e0010>&#39;</span>, stop reason <span style=color:#f92672>=</span> step in
    frame <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0x0000000100003fb2</span> a.out<span style=color:#960050;background-color:#1e0010>`</span>main at zero.cc:<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>
   <span style=color:#ae81ff>1</span>    <span style=color:#66d9ef>int</span> main() {
   <span style=color:#ae81ff>2</span>        <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
<span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>3</span>        <span style=color:#66d9ef>return</span> i;
   <span style=color:#ae81ff>4</span>    }

(lldb) expr i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
(<span style=color:#66d9ef>int</span>) <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
(lldb) expr (<span style=color:#66d9ef>float</span>)i <span style=color:#f92672>+</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>1.4</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span>
(<span style=color:#66d9ef>float</span>) <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
</code></pre></div><p>^ example of expression evaluation in LLDB</p><p>The expression evaluator can be implemented as an interpreter of the target language (that&rsquo;s what GDB does for C++, for example) or by re-using the bits of the compiler infrastructure (e.g. LLDB uses Clang, C# debugger in Visual Studio uses Roslyn). Often it&rsquo;s a combination, when the compiler can be used as a library and behaves differenly when invoked by the debugger (this is how C# worked in earlier versions of Visual Studio, <a href=https://twitter.com/AnsonHorton/status/1343901623962103809>twitter thread</a>).</p><blockquote><p>If you&rsquo;re interesting in the unusual debugger architectures, read about <a href=https://plan9.io/sys/doc/acidpaper.html>ACID</a> &ndash; the debugger implemented as a language interpreter with specialized primitives that provide debugger support.</p></blockquote><hr><p><a href=https://lldb.llvm.org/>LLDB</a> is the debugger component of the LLVM project. It is built as a set of reusable components which extensively use existing libraries from LLVM, such as the Clang expression parser and LLVM disassembler<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>LLDB has a very powerfull built-in expression evaluator, powered by <a href=https://clang.llvm.org/>Clang</a>. It can handle almost any valid C++ as well as perform function calls. But the downside of this power is poor performance, especially for large programs with lots of debug information. This is not as critical for interactive use, but doesn&rsquo;t work well for implementing IDE integrations. For example, <a href=https://github.com/googlestadia/vsi-lldb>Stadia debugger for Visual Studio</a> evaluates dozens and hundreds of expressions for every &ldquo;step&rdquo;, so it has to be fast. Nobody likes slow debuggers!</p><p>This is where <a href=https://github.com/google/lldb-eval>lldb-eval</a> comes in. It&rsquo;s a library for evaluating C++ like expressions in the debugger context, built with performance in mind. It&rsquo;s designed around LLDB, has very similar API and in many cases can be used as a drop-in replacement. The primary use-case is IDE integration (namely, <a href=https://github.com/googlestadia/vsi-lldb>Stadia for Visual Studio</a>). The rest of this post is about the library architecture and design decisions behind it.</p><p><code>lldb-eval</code> is open-source and available on GitHub &ndash; <a href=https://github.com/google/lldb-eval>https://github.com/google/lldb-eval</a>.</p><h2 id=overview>Overview
<a class=heading-link href=#overview><i class="fa fa-link" aria-hidden=true></i></a></h2><p><img src=lldb-eval-inception.jpg alt=image></p><p>Basically <code>lldb-eval</code> is an interpreter for a subset of C++, written in C++. Like a typical interpreter it has a parser that produces an expression AST and an evaluator that evaluates that AST. The parser performs type-checking and semantics analysis, while the evaluator implements the runtime control flow analysis.</p><h2 id=expression-language>Expression language
<a class=heading-link href=#expression-language><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The expression language is a subset of C++ (<a href=https://github.com/google/lldb-eval/blob/master/docs/expr-lang.ebnf>EBNF grammar</a>). The grammar supports all basic C++ features: arithmetic operators, members access, C-style and C++-style casts, function calls (for supported debugger intrinsics). Overall the set of features is aimed to be compatible with other debuggers and <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019#BKMK_Expressions_and_formatting">NatVis rules</a>.</p><h2 id=parser>Parser
<a class=heading-link href=#parser><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The first core component in <code>lldb-eval</code> is <code>Parser</code> (<a href=https://github.com/google/lldb-eval/blob/master/lldb-eval/parser.h>parser.h</a>). It&rsquo;s a classic <a href=https://en.wikipedia.org/wiki/Recursive_descent_parser>recursive descent parser</a> with several modifications to accomodate for C++ grammar. Since C++ cannot be expressed in pure <a href=https://en.wikipedia.org/wiki/LL_grammar>LL grammar</a>, the parser performs limited look-ahead and has the ability to do tentative parsing with rollbacks. The input data is limited to one C++ <em>expression</em>, although it can be multi-line and arbitrarily long.</p><p>The parser relies on <code>clang</code> library to do the lexing and preprocessing (using <code>clang::Preprocessor</code>) and then processes the stream of C++ token to build an expression <a href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>AST</a>. The AST is annotated, meaning that the parser resolves the type for every node and performs the type checking and semantic analysis. The parser tries to produce rich diagnostics (with source locations whenever possible), most errors messages are similar to <code>clang</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#f92672>&gt;</span> test<span style=color:#f92672>::</span>foo.bar<span style=color:#f92672>-&gt;</span>baz.x
<span style=color:#f92672>&lt;</span>expr<span style=color:#f92672>&gt;:</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>14</span><span style=color:#f92672>:</span> member reference type <span style=color:#960050;background-color:#1e0010>&#39;</span>test<span style=color:#f92672>::</span>Bar<span style=color:#960050;background-color:#1e0010>&#39;</span> is not a pointer; did you mean to use <span style=color:#e6db74>&#39;.&#39;</span><span style=color:#f92672>?</span>
test<span style=color:#f92672>::</span>foo.bar<span style=color:#f92672>-&gt;</span>baz.x
             <span style=color:#f92672>^</span>

<span style=color:#f92672>&gt;</span> test<span style=color:#f92672>::</span>foo.bar.baz <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>
<span style=color:#f92672>&lt;</span>expr<span style=color:#f92672>&gt;:</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>19</span><span style=color:#f92672>:</span> invalid operands to binary expression (<span style=color:#960050;background-color:#1e0010>&#39;</span>test<span style=color:#f92672>::</span>Baz<span style=color:#960050;background-color:#1e0010>&#39;</span> and <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#66d9ef>int</span><span style=color:#960050;background-color:#1e0010>&#39;</span>)
test<span style=color:#f92672>::</span>foo.bar.baz <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>
                  <span style=color:#f92672>^</span>
</code></pre></div><h3 id=identifier-resolution>Identifier resolution
<a class=heading-link href=#identifier-resolution><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Unlike the regular compiler, <code>lldb-eval</code> resolves the expression in the debugger context and uses the debug information from the target process (DWARF, PDB) to resolve the identifiers (variables, types). If the binary being debugged doesn&rsquo;t have the debug information and symbols, there isn&rsquo;t much <code>lldb-eval</code> can do about it. Same goes for binaries built with higher optimization levels &ndash; some symbols might be optimized away (e.g. unused types and variables are first candidates for removal) and the expression evaluator will not be able to use them. These restrictions are not really specific for <code>lldb-eval</code>. If some variable is optimized away, you will not be able to see its value using commands like <code>frame variable</code> either.</p><p>To resolve an identifier, it&rsquo;s not sufficient to just perform a name lookup (and, unfortunately, that&rsquo;s basically the API we have &ndash; <code>FindTypes(name)</code> and <code>FindVariables(name)</code>). C++ uses namespaces and classes/structs to define scoping rules. E.g. <code>int foo::bar</code> is different from <code>int baz::bar</code> (<code>foo</code> and <code>baz</code> being namespaces). When the parser encounters an identifier <code>bar</code> it needs to resolve it. Is it a <em>variable</em> from <code>foo</code>? Or maybe it&rsquo;s a <em>type</em> defined in <code>other_namespace</code>? In C++ it&rsquo;s possible to declare variables and types almost anywhere, so a proper resolver should take the hierarchical scoping rules into account:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>using</span> myint <span style=color:#f92672>=</span> <span style=color:#66d9ef>int</span>;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>() {
  <span style=color:#75715e>// `(myint)1.5` is 1
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>namespace</span> ns {

<span style=color:#66d9ef>using</span> myint <span style=color:#f92672>=</span> <span style=color:#66d9ef>double</span>;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>() {
  <span style=color:#75715e>// `(myint)1.5` is 1.5
</span><span style=color:#75715e></span>
  <span style=color:#75715e>// Credit @cor3ntin -- https://twitter.com/cor3ntin/status/1373773782700146689
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> myint; myint x : {<span style=color:#ae81ff>1.5</span>}) {
    <span style=color:#75715e>// `(myint)1.5` is 1 ðŸ˜±
</span><span style=color:#75715e></span>  }
}

}
</code></pre></div><p>But C++ grammar is even more complicated than that and allows for a lot of ambiguities. Depending on the surrounding context the same expression can mean very different things. Consider the expression <code>(myint)-1</code>. Your first (very reasonable) guess was probably that it&rsquo;s a cast of <code>-1</code> to the type <code>myint</code>. However that can also be an arithmetic operation if <code>myint</code> is a variable!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> myint <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func_1</span>() {
  <span style=color:#75715e>// `(myint)-1` is 0
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func_2</span>() {
  <span style=color:#66d9ef>using</span> myint <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint16_t</span>;
  <span style=color:#75715e>// `(myint)-1` is 65535 ðŸ˜±
</span><span style=color:#75715e></span>}
</code></pre></div><p>The C++ <em>compiler</em> can easily resolve <code>myint</code>, because it knows exactly what the current scope is. All shadowing operations have already been applied (i.e. <code>using myint</code> shadowed <code>int myint</code>), so the resolution is unambiguous. The parser in <code>lldb-eval</code>, however, doesn&rsquo;t have the scope information, it can only lookup identifiers by their names. The best we can do is to get the current scope (e.g. <code>int foo::bar()</code>) and then look for the &ldquo;closest&rdquo; symbol in the hierarchy of this scope. For example, if the current frame is <code>int ns::Class::foo()</code>, we can look for (<code>ns::Class::foo::bar</code>, <code>ns::Class::bar</code>, <code>ns::bar</code>, <code>::bar</code>) and take the first match.</p><p>There are other limitations we face when using public LLDB API. For example, static const members and enum constants are not currently being indexed by LLDB, even though they&rsquo;re present in the DWARF debug info. There are patches to improve this, but it&rsquo;s still work in progress:</p><ul><li><a href=https://reviews.llvm.org/D92643>Lookup unscoped enumeration members</a></li><li><a href=https://reviews.llvm.org/D94077>Lookup static const members</a></li></ul><h3 id=semantic-analysis>Semantic analysis
<a class=heading-link href=#semantic-analysis><i class="fa fa-link" aria-hidden=true></i></a></h3><p>The semantic analysis in <code>lldb-eval</code> is heavily inspired by other C++ compilers (GCC, Clang) and, at its core, is very similar to what they do. The parser resolves the types and performs all kinds of checks to verify that the given expression is valid in the <em>current context</em>. This includes simple checks like detecting addition of incompatible types (e.g. <code>int</code> and <code>Foo</code>), as well as more complicated <a href=https://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_promotions>integral promotions</a>, implicit type conversions and <code>lvalue/rvalue</code> control flow analysis.</p><p>That said, the parser has a number of deliberate deviations from C++ spec due to the fact that the expression interpreter in the debugger has a slightly different goal than the compiler. The compiler is meant to verify that the code is correct and produce the most optimal output, while still maintaining all the invariants of the language specification. The debugger, however, aims to help the developer in inspecting the program state.</p><p>For example, in C++ it is illegal to compare pointers with numeric literals except for literal zero:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

p <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// error: comparison between pointer and integer (&#39;int *&#39; and &#39;int&#39;)
</span><span style=color:#75715e></span>p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// OK, literal zero is allowed
</span></code></pre></div><p>The debuggers usually allow this (the example is LLDB, but GDB and MSVC do the same):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>Process <span style=color:#ae81ff>32964</span> stopped
<span style=color:#f92672>*</span> <span style=color:#66d9ef>thread</span> <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>1</span>, queue <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>&#39;</span>com.apple.main<span style=color:#f92672>-</span><span style=color:#66d9ef>thread</span><span style=color:#960050;background-color:#1e0010>&#39;</span>, stop reason <span style=color:#f92672>=</span> step in
    frame <span style=color:#960050;background-color:#1e0010>#</span><span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0x0000000100003fb5</span> a.out<span style=color:#960050;background-color:#1e0010>`</span>main at zero.cc:<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>5</span>
   <span style=color:#ae81ff>1</span>    <span style=color:#66d9ef>int</span> main() {
   <span style=color:#ae81ff>2</span>        <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>3</span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
   <span style=color:#ae81ff>4</span>    }

(lldb) p p <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
(<span style=color:#66d9ef>bool</span>) <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> false
(lldb) p p <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
(<span style=color:#66d9ef>bool</span>) <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>=</span> true
</code></pre></div><p>Clang <a href=https://github.com/llvm/llvm-project/blob/5b2d8503d1d4b925e30fd2b91f97bfd625f03157/clang/lib/Sema/SemaExpr.cpp#L11971-L11972>explicitly allows this</a> if the expression is being parsed in the debugger context. Same goes for <a href=https://github.com/llvm/llvm-project/blob/5b2d8503d1d4b925e30fd2b91f97bfd625f03157/clang/lib/Sema/SemaExprMember.cpp#L1421>accessing private and protected members</a> of classes and structs. <em>Of course</em> if someone types <code>foo->x_</code>, they don&rsquo;t expect to get <code>'x_' is a private member of 'Foo'</code>. That&rsquo;s why <code>lldb-eval</code> is less strict than the compiler and tries to do what the user expects in the given context.</p><p><img src=lldb-eval-vs-compiler.jpg alt=image></p><h2 id=interpreter>Interpreter
<a class=heading-link href=#interpreter><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The second core component in <code>lldb-eval</code> is the <code>Interpreter</code> (<a href=https://github.com/google/lldb-eval/blob/master/lldb-eval/eval.h>eval.h</a>). It takes the AST produced by the parser and recursively evaluates it. Typically interpreters convert the AST to some kind of <a href=https://en.wikipedia.org/wiki/Bytecode>bytecode</a> or <a href=https://en.wikipedia.org/wiki/Intermediate_representation>IR</a> first, but <code>lldb-eval</code> skips this step for simplicity.</p><p>Since the parser is guaranteed to produce a <em>valid</em> AST (or give a reasonable error), the <code>Interpreter</code> makes an assumption of correctness &ndash; all the types match, all casts are correct, all functions have correct number of arguments, etc. This doesn&rsquo;t prevent <em>runtime</em> errors though. For example, one can still dereference a null pointer &ndash; <code>*(int*)0 + 1</code>. The parser will be happy, but the interpreter will have to deal with zero pointer.</p><p>The interpreter implements a number of optimizations related to UB (undefined behavior) described in C++ specification. A little known fact, it&rsquo;s actually perfectly legal to dereference a null pointer <em>as long as the result of the dereference is not used</em>. For example, this is well-formed C++:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>( true <span style=color:#f92672>?</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> x );

<span style=color:#75715e>// `p + 1` is 1;
</span></code></pre></div><p>The interpreter performs flow control analysis, detects when the result of the dereference is not used and eliminates the &ldquo;pair&rdquo; operations of <code>&*</code>. Same logic also applies for member access (which is <em>basically</em> a dereference):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=color:#66d9ef>auto</span> p <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>((Foo<span style=color:#f92672>*</span>)<span style=color:#ae81ff>0</span>)<span style=color:#f92672>-&gt;</span>foo_;

<span style=color:#75715e>// `p` is the offset of `foo_` in `Foo`.
</span></code></pre></div><p>Implementing this properly, however, is more complicated, because in general it&rsquo;s not possible to calculate the offset &ldquo;statically&rdquo;. If the object in question has virtual base classes, the debug information might not contain all the required information and the offset should be calculated at runtime using the <a href=https://en.wikipedia.org/wiki/Virtual_method_table>vtable</a>. This is doable, but not yet implemented in <code>lldb-eval</code>.</p><h2 id=api>API
<a class=heading-link href=#api><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>lldb-eval</code> has a minimalistic <a href=lldb-eval/api.h>API</a> which is very similar to LLDB API (not surprising, given that it builds on top on <code>LLDB</code>). The basic method looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>lldb<span style=color:#f92672>::</span>SBValue EvaluateExpression(
  lldb<span style=color:#f92672>::</span>SBFrame frame, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> expression, lldb<span style=color:#f92672>::</span>SBError<span style=color:#f92672>&amp;</span> error);
</code></pre></div><p>Usually you&rsquo;d want the stack frame where the program is currently stopped, but it&rsquo;s possible to use any valid one (e.g. from another thread or to inspect the variables of the caller function).</p><p>There&rsquo;s a option of using <code>lldb::SBValue</code> instead of <code>lldb::SBFrame</code>, then the expression is evaluated in the context of the given object:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>lldb<span style=color:#f92672>::</span>SBValue EvaluateExpression(
  lldb<span style=color:#f92672>::</span>SBValue scope, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> expression, lldb<span style=color:#f92672>::</span>SBError<span style=color:#f92672>&amp;</span> error);
</code></pre></div><p>For example, <code>this->foo_</code> or just <code>foo_</code> will refer to the member of the context object, not the variable in the current stack frame. This is very useful when evaluating custom visualization logic like <a href=https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects>NatVis</a>.</p><h3 id=maintaning-state>Maintaning state
<a class=heading-link href=#maintaning-state><i class="fa fa-link" aria-hidden=true></i></a></h3><p><code>lldb-eval</code> is stateless (and thread-safe), but sometimes it&rsquo;s useful to have some state that the expressions can access and modify. For example, in NatVis <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019#customlistitems-expansion">CustomListItems</a> allows you to declare variables that can be modified by the expression. Typical examples &ndash; a counter or a pointer to a bucket in hash-table.</p><p>Both versions of <code>EvaluateExpression</code> allow passing of a list of external identifiers/values that can be used by the expression. This makes it possible to have a state between the expression evaluations, while keeping the library stateless:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>lldb<span style=color:#f92672>::</span>SBError ignore;
lldb<span style=color:#f92672>::</span>SBValue counter <span style=color:#f92672>=</span> lldb_eval<span style=color:#f92672>::</span>EvaluateExpression(frame, <span style=color:#e6db74>&#34;10&#34;</span>, ignore);

lldb_eval<span style=color:#f92672>::</span>ContextVariable var;
var.name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;counter&#34;</span>;
var.value <span style=color:#f92672>=</span> counter;

lldb_eval<span style=color:#f92672>::</span>ContextVariableList vars;
vars.data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>var;
vars.size <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;

<span style=color:#66d9ef>while</span> (counter.GetValueAsUnsigned() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
  lldb_eval<span style=color:#f92672>::</span>EvaluateExpression(frame, <span style=color:#e6db74>&#34;--counter&#34;</span>, vars, ignore);
}
</code></pre></div><p>The code above creates a <code>counter</code> with initial value of <code>10</code> and then decrements it in a loop.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/LLDB_(debugger)>https://en.wikipedia.org/wiki/LLDB_(debugger)</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//werat-github-io.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></section></div><footer class=footer><section class=container>Â©
2017 -
2021
Andy Hippo
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.235666b114443867d43eeb5799d51f6252965e5163f338285e113fa381d3d27e.js integrity="sha256-I1ZmsRREOGfUPutXmdUfYlKWXlFj8zgoXhE/o4HT0n4="></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-91441325-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-91441325-1')</script></body></html>