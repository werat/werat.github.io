<!doctype html><html lang=en><head><title>Blazing fast expression evaluation for C++ in LLDB</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Andy Hippo"><meta name=description content="Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like print/call in GDB or expr/p in LLDB. It is also used extensively by the IDEs to support typical UI workflows: Immediate Window, Watch Window, hovering over a variable, custom data visualizers (see NatVis), etc."><meta name=keywords content="blog,developer,personal,lldb,debugging,open-source,c++"><meta name=twitter:card content="summary"><meta name=twitter:title content="Blazing fast expression evaluation for C++ in LLDB"><meta name=twitter:description content="Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like print/call in GDB or expr/p in LLDB. It is also used extensively by the IDEs to support typical UI workflows: Immediate Window, Watch Window, hovering over a variable, custom data visualizers (see NatVis), etc."><meta property="og:title" content="Blazing fast expression evaluation for C++ in LLDB"><meta property="og:description" content="Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like print/call in GDB or expr/p in LLDB. It is also used extensively by the IDEs to support typical UI workflows: Immediate Window, Watch Window, hovering over a variable, custom data visualizers (see NatVis), etc."><meta property="og:type" content="article"><meta property="og:url" content="https://werat.dev/blog/blazing-fast-expression-evaluation-for-c-in-lldb/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-23T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-23T00:00:00+00:00"><link rel=canonical href=https://werat.dev/blog/blazing-fast-expression-evaluation-for-c-in-lldb/><link rel=alternate type=application/rss+xml title=werat.dev href=https://werat.dev/index.xml><link rel=icon href=/favicon.ico sizes=any><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=manifest href=/manifest.webmanifest><link rel=stylesheet href=/css/main.css><meta name=generator content="Hugo 0.111.2"></head><body><header class=nav-header><nav><span class=nav-title><a href=/>werat.dev</a></span>
<a href=/posts/>Blog</a>
<a href=/talks/>Talks</a></nav></header><main><article><header><h1 class=title>Blazing fast expression evaluation for C++ in LLDB</h1><time class=posted-on datetime=2021-03-23T00:00:00Z>March 23, 2021</time></header><p>Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&rsquo;re probably familiar with it via commands like <code>print</code>/<code>call</code> in GDB or <code>expr</code>/<code>p</code> in LLDB. It is also used extensively by the IDEs to support typical UI workflows: <a href="https://docs.microsoft.com/en-us/visualstudio/ide/reference/immediate-window?view=vs-2019">Immediate Window</a>, <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/watch-and-quickwatch-windows?view=vs-2019">Watch Window</a>, hovering over a variable, custom data visualizers (see <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019">NatVis</a>), etc.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>*</span> <span style=color:#a90d91>thread</span> <span style=color:#000>#</span><span style=color:#1c01ce>1</span>, <span style=color:#000>queue</span> <span style=color:#000>=</span> <span style=color:#000>&#39;</span><span style=color:#000>com</span>.<span style=color:#000>apple</span>.<span style=color:#000>main</span><span style=color:#000>-</span><span style=color:#a90d91>thread</span><span style=color:#000>&#39;</span>, <span style=color:#000>stop</span> <span style=color:#000>reason</span> <span style=color:#000>=</span> <span style=color:#000>step</span> <span style=color:#000>in</span>
</span></span><span style=display:flex><span>    <span style=color:#000>frame</span> <span style=color:#000>#</span><span style=color:#1c01ce>0</span><span style=color:#000>:</span> <span style=color:#1c01ce>0x0000000100003fb2</span> <span style=color:#000>a</span>.<span style=color:#000>out</span><span style=color:#000>`</span><span style=color:#000>main</span> <span style=color:#000>at</span> <span style=color:#000>zero</span>.<span style=color:#000>cc</span>:<span style=color:#1c01ce>3</span><span style=color:#000>:</span><span style=color:#1c01ce>12</span>
</span></span><span style=display:flex><span>   <span style=color:#1c01ce>1</span>    <span style=color:#a90d91>int</span> <span style=color:#000>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#1c01ce>2</span>        <span style=color:#a90d91>int</span> <span style=color:#000>i</span> <span style=color:#000>=</span> <span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span><span style=color:#000>-&gt;</span> <span style=color:#1c01ce>3</span>        <span style=color:#a90d91>return</span> <span style=color:#000>i</span>;
</span></span><span style=display:flex><span>   <span style=color:#1c01ce>4</span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#000>lldb</span>) <span style=color:#000>expr</span> <span style=color:#000>i</span> <span style=color:#000>+</span> <span style=color:#1c01ce>1</span>
</span></span><span style=display:flex><span>(<span style=color:#a90d91>int</span>) <span style=color:#000>$</span><span style=color:#1c01ce>0</span> <span style=color:#000>=</span> <span style=color:#1c01ce>2</span>
</span></span><span style=display:flex><span>(<span style=color:#000>lldb</span>) <span style=color:#000>expr</span> (<span style=color:#a90d91>float</span>)<span style=color:#000>i</span> <span style=color:#000>+</span> <span style=color:#a90d91>static_cast</span><span style=color:#000>&lt;</span><span style=color:#a90d91>int</span><span style=color:#000>&gt;</span>(<span style=color:#1c01ce>1.4</span>) <span style=color:#000>*</span> <span style=color:#1c01ce>3</span>
</span></span><span style=display:flex><span>(<span style=color:#a90d91>float</span>) <span style=color:#000>$</span><span style=color:#1c01ce>1</span> <span style=color:#000>=</span> <span style=color:#1c01ce>4</span>
</span></span></code></pre></div><p>^ example of expression evaluation in LLDB</p><p>The expression evaluator can be implemented as an interpreter of the target language (that&rsquo;s what GDB does for C++, for example) or by re-using the bits of the compiler infrastructure (e.g. LLDB uses Clang, C# debugger in Visual Studio uses Roslyn). Often it&rsquo;s a combination, when the compiler can be used as a library and behaves differenly when invoked by the debugger (this is how C# worked in earlier versions of Visual Studio, <a href=https://twitter.com/AnsonHorton/status/1343901623962103809>twitter thread</a>).</p><blockquote><p>If you&rsquo;re interesting in the unusual debugger architectures, read about <a href=https://plan9.io/sys/doc/acidpaper.html>ACID</a> &ndash; the debugger implemented as a language interpreter with specialized primitives that provide debugger support.</p></blockquote><hr><p><a href=https://lldb.llvm.org/>LLDB</a> is the debugger component of the LLVM project. It is built as a set of reusable components which extensively use existing libraries from LLVM, such as the Clang expression parser and LLVM disassembler.</p><p>LLDB has a very powerfull built-in expression evaluator, powered by <a href=https://clang.llvm.org/>Clang</a>. It can handle almost any valid C++ as well as perform function calls. But the downside of this power is poor performance, especially for large programs with lots of debug information. This is not as critical for interactive use, but doesn&rsquo;t work well for implementing IDE integrations. For example, <a href=https://github.com/googlestadia/vsi-lldb>Stadia debugger for Visual Studio</a> evaluates dozens and hundreds of expressions for every &ldquo;step&rdquo;, so it has to be fast. Nobody likes slow debuggers!</p><p>This is where <a href=https://github.com/google/lldb-eval>lldb-eval</a> comes in. It&rsquo;s a library for evaluating C++ like expressions in the debugger context, built with performance in mind. It&rsquo;s designed around LLDB, has very similar API and in many cases can be used as a drop-in replacement. The primary use-case is IDE integration (namely, <a href=https://github.com/googlestadia/vsi-lldb>Stadia for Visual Studio</a>). The rest of this post is about the library architecture and design decisions behind it.</p><p><code>lldb-eval</code> is open-source and available on GitHub &ndash; <a href=https://github.com/google/lldb-eval>https://github.com/google/lldb-eval</a>.</p><h2 id=overview>Overview
<a class=heading-link href=#overview>#</a></h2><p><img src=lldb-eval-inception.jpg alt=image width=622 height=401></p><p>Basically <code>lldb-eval</code> is an interpreter for a subset of C++, written in C++. Like a typical interpreter it has a parser that produces an expression AST and an evaluator that evaluates that AST. The parser performs type-checking and semantics analysis, while the evaluator implements the runtime control flow analysis.</p><h2 id=expression-language>Expression language
<a class=heading-link href=#expression-language>#</a></h2><p>The expression language is a subset of C++ (<a href=https://github.com/google/lldb-eval/blob/master/docs/expr-lang.ebnf>EBNF grammar</a>). The grammar supports all basic C++ features: arithmetic operators, members access, C-style and C++-style casts, function calls (for supported debugger intrinsics). Overall the set of features is aimed to be compatible with other debuggers and <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019#BKMK_Expressions_and_formatting">NatVis rules</a>.</p><h2 id=parser>Parser
<a class=heading-link href=#parser>#</a></h2><p>The first core component in <code>lldb-eval</code> is <code>Parser</code> (<a href=https://github.com/google/lldb-eval/blob/master/lldb-eval/parser.h>parser.h</a>). It&rsquo;s a classic <a href=https://en.wikipedia.org/wiki/Recursive_descent_parser>recursive descent parser</a> with several modifications to accomodate for C++ grammar. Since C++ cannot be expressed in pure <a href=https://en.wikipedia.org/wiki/LL_grammar>LL grammar</a>, the parser performs limited look-ahead and has the ability to do tentative parsing with rollbacks. The input data is limited to one C++ <em>expression</em>, although it can be multi-line and arbitrarily long.</p><p>The parser relies on <code>clang</code> library to do the lexing and preprocessing (using <code>clang::Preprocessor</code>) and then processes the stream of C++ token to build an expression <a href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>AST</a>. The AST is annotated, meaning that the parser resolves the type for every node and performs the type checking and semantic analysis. The parser tries to produce rich diagnostics (with source locations whenever possible), most errors messages are similar to <code>clang</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>&gt;</span> <span style=color:#000>test</span><span style=color:#000>::</span><span style=color:#000>foo</span>.<span style=color:#000>bar</span><span style=color:#000>-&gt;</span><span style=color:#000>baz</span>.<span style=color:#000>x</span>
</span></span><span style=display:flex><span><span style=color:#000>&lt;</span><span style=color:#000>expr</span><span style=color:#000>&gt;:</span><span style=color:#1c01ce>1</span><span style=color:#000>:</span><span style=color:#1c01ce>14</span><span style=color:#000>:</span> <span style=color:#000>member</span> <span style=color:#000>reference</span> <span style=color:#000>type</span> <span style=color:#000>&#39;</span><span style=color:#000>test</span><span style=color:#000>::</span><span style=color:#000>Bar</span><span style=color:#000>&#39;</span> <span style=color:#000>is</span> <span style=color:#000>not</span> <span style=color:#000>a</span> <span style=color:#000>pointer</span>; <span style=color:#000>did</span> <span style=color:#000>you</span> <span style=color:#000>mean</span> <span style=color:#000>to</span> <span style=color:#000>use</span> <span style=color:#2300ce>&#39;.&#39;</span><span style=color:#000>?</span>
</span></span><span style=display:flex><span><span style=color:#000>test</span><span style=color:#000>::</span><span style=color:#000>foo</span>.<span style=color:#000>bar</span><span style=color:#000>-&gt;</span><span style=color:#000>baz</span>.<span style=color:#000>x</span>
</span></span><span style=display:flex><span>             <span style=color:#000>^</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>&gt;</span> <span style=color:#000>test</span><span style=color:#000>::</span><span style=color:#000>foo</span>.<span style=color:#000>bar</span>.<span style=color:#000>baz</span> <span style=color:#000>+</span> <span style=color:#1c01ce>2</span>
</span></span><span style=display:flex><span><span style=color:#000>&lt;</span><span style=color:#000>expr</span><span style=color:#000>&gt;:</span><span style=color:#1c01ce>1</span><span style=color:#000>:</span><span style=color:#1c01ce>19</span><span style=color:#000>:</span> <span style=color:#000>invalid</span> <span style=color:#000>operands</span> <span style=color:#000>to</span> <span style=color:#000>binary</span> <span style=color:#000>expression</span> (<span style=color:#000>&#39;</span><span style=color:#000>test</span><span style=color:#000>::</span><span style=color:#000>Baz</span><span style=color:#000>&#39;</span> <span style=color:#000>and</span> <span style=color:#000>&#39;</span><span style=color:#a90d91>int</span><span style=color:#000>&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#000>test</span><span style=color:#000>::</span><span style=color:#000>foo</span>.<span style=color:#000>bar</span>.<span style=color:#000>baz</span> <span style=color:#000>+</span> <span style=color:#1c01ce>2</span>
</span></span><span style=display:flex><span>                  <span style=color:#000>^</span>
</span></span></code></pre></div><h3 id=identifier-resolution>Identifier resolution
<a class=heading-link href=#identifier-resolution>#</a></h3><p>Unlike the regular compiler, <code>lldb-eval</code> resolves the expression in the debugger context and uses the debug information from the target process (DWARF, PDB) to resolve the identifiers (variables, types). If the binary being debugged doesn&rsquo;t have the debug information and symbols, there isn&rsquo;t much <code>lldb-eval</code> can do about it. Same goes for binaries built with higher optimization levels &ndash; some symbols might be optimized away (e.g. unused types and variables are first candidates for removal) and the expression evaluator will not be able to use them. These restrictions are not really specific for <code>lldb-eval</code>. If some variable is optimized away, you will not be able to see its value using commands like <code>frame variable</code> either.</p><p>To resolve an identifier, it&rsquo;s not sufficient to just perform a name lookup (and, unfortunately, that&rsquo;s basically the API we have &ndash; <code>FindTypes(name)</code> and <code>FindVariables(name)</code>). C++ uses namespaces and classes/structs to define scoping rules. E.g. <code>int foo::bar</code> is different from <code>int baz::bar</code> (<code>foo</code> and <code>baz</code> being namespaces). When the parser encounters an identifier <code>bar</code> it needs to resolve it. Is it a <em>variable</em> from <code>foo</code>? Or maybe it&rsquo;s a <em>type</em> defined in <code>other_namespace</code>? In C++ it&rsquo;s possible to declare variables and types almost anywhere, so a proper resolver should take the hierarchical scoping rules into account:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>using</span> <span style=color:#000>myint</span> <span style=color:#000>=</span> <span style=color:#a90d91>int</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>void</span> <span style=color:#000>func</span>() {
</span></span><span style=display:flex><span>  <span style=color:#177500>// `(myint)1.5` is 1
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>namespace</span> <span style=color:#000>ns</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>using</span> <span style=color:#000>myint</span> <span style=color:#000>=</span> <span style=color:#a90d91>double</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>void</span> <span style=color:#000>func</span>() {
</span></span><span style=display:flex><span>  <span style=color:#177500>// `(myint)1.5` is 1.5
</span></span></span><span style=display:flex><span><span style=color:#177500></span>
</span></span><span style=display:flex><span>  <span style=color:#177500>// Credit @cor3ntin -- https://twitter.com/cor3ntin/status/1373773782700146689
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  <span style=color:#a90d91>for</span> (<span style=color:#a90d91>typedef</span> <span style=color:#a90d91>int</span> <span style=color:#000>myint</span>; <span style=color:#000>myint</span> <span style=color:#000>x</span> : {<span style=color:#1c01ce>1.5</span>}) {
</span></span><span style=display:flex><span>    <span style=color:#177500>// `(myint)1.5` is 1 😱
</span></span></span><span style=display:flex><span><span style=color:#177500></span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But C++ grammar is even more complicated than that and allows for a lot of ambiguities. Depending on the surrounding context the same expression can mean very different things. Consider the expression <code>(myint)-1</code>. Your first (very reasonable) guess was probably that it&rsquo;s a cast of <code>-1</code> to the type <code>myint</code>. However that can also be an arithmetic operation if <code>myint</code> is a variable!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>int</span> <span style=color:#000>myint</span> <span style=color:#000>=</span> <span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>void</span> <span style=color:#000>func_1</span>() {
</span></span><span style=display:flex><span>  <span style=color:#177500>// `(myint)-1` is 0
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>void</span> <span style=color:#000>func_2</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a90d91>using</span> <span style=color:#000>myint</span> <span style=color:#000>=</span> <span style=color:#a90d91>uint16_t</span>;
</span></span><span style=display:flex><span>  <span style=color:#177500>// `(myint)-1` is 65535 😱
</span></span></span><span style=display:flex><span><span style=color:#177500></span>}
</span></span></code></pre></div><p>The C++ <em>compiler</em> can easily resolve <code>myint</code>, because it knows exactly what the current scope is. All shadowing operations have already been applied (i.e. <code>using myint</code> shadowed <code>int myint</code>), so the resolution is unambiguous. The parser in <code>lldb-eval</code>, however, doesn&rsquo;t have the scope information, it can only lookup identifiers by their names. The best we can do is to get the current scope (e.g. <code>int foo::bar()</code>) and then look for the &ldquo;closest&rdquo; symbol in the hierarchy of this scope. For example, if the current frame is <code>int ns::Class::foo()</code>, we can look for (<code>ns::Class::foo::bar</code>, <code>ns::Class::bar</code>, <code>ns::bar</code>, <code>::bar</code>) and take the first match.</p><p>There are other limitations we face when using public LLDB API. For example, static const members and enum constants are not currently being indexed by LLDB, even though they&rsquo;re present in the DWARF debug info. There are patches to improve this, but it&rsquo;s still work in progress:</p><ul><li><a href=https://reviews.llvm.org/D92643>Lookup unscoped enumeration members</a></li><li><a href=https://reviews.llvm.org/D94077>Lookup static const members</a></li></ul><h3 id=semantic-analysis>Semantic analysis
<a class=heading-link href=#semantic-analysis>#</a></h3><p>The semantic analysis in <code>lldb-eval</code> is heavily inspired by other C++ compilers (GCC, Clang) and, at its core, is very similar to what they do. The parser resolves the types and performs all kinds of checks to verify that the given expression is valid in the <em>current context</em>. This includes simple checks like detecting addition of incompatible types (e.g. <code>int</code> and <code>Foo</code>), as well as more complicated <a href=https://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_promotions>integral promotions</a>, implicit type conversions and <code>lvalue/rvalue</code> control flow analysis.</p><p>That said, the parser has a number of deliberate deviations from C++ spec due to the fact that the expression interpreter in the debugger has a slightly different goal than the compiler. The compiler is meant to verify that the code is correct and produce the most optimal output, while still maintaining all the invariants of the language specification. The debugger, however, aims to help the developer in inspecting the program state.</p><p>For example, in C++ it is illegal to compare pointers with numeric literals except for literal zero:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>int</span><span style=color:#000>*</span> <span style=color:#000>p</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>p</span> <span style=color:#000>==</span> <span style=color:#1c01ce>1</span>;  <span style=color:#177500>// error: comparison between pointer and integer (&#39;int *&#39; and &#39;int&#39;)
</span></span></span><span style=display:flex><span><span style=color:#177500></span><span style=color:#000>p</span> <span style=color:#000>==</span> <span style=color:#1c01ce>0</span>;  <span style=color:#177500>// OK, literal zero is allowed
</span></span></span></code></pre></div><p>The debuggers usually allow this (the example is LLDB, but GDB and MSVC do the same):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>Process</span> <span style=color:#1c01ce>32964</span> <span style=color:#000>stopped</span>
</span></span><span style=display:flex><span><span style=color:#000>*</span> <span style=color:#a90d91>thread</span> <span style=color:#000>#</span><span style=color:#1c01ce>1</span>, <span style=color:#000>queue</span> <span style=color:#000>=</span> <span style=color:#000>&#39;</span><span style=color:#000>com</span>.<span style=color:#000>apple</span>.<span style=color:#000>main</span><span style=color:#000>-</span><span style=color:#a90d91>thread</span><span style=color:#000>&#39;</span>, <span style=color:#000>stop</span> <span style=color:#000>reason</span> <span style=color:#000>=</span> <span style=color:#000>step</span> <span style=color:#000>in</span>
</span></span><span style=display:flex><span>    <span style=color:#000>frame</span> <span style=color:#000>#</span><span style=color:#1c01ce>0</span><span style=color:#000>:</span> <span style=color:#1c01ce>0x0000000100003fb5</span> <span style=color:#000>a</span>.<span style=color:#000>out</span><span style=color:#000>`</span><span style=color:#000>main</span> <span style=color:#000>at</span> <span style=color:#000>zero</span>.<span style=color:#000>cc</span>:<span style=color:#1c01ce>3</span><span style=color:#000>:</span><span style=color:#1c01ce>5</span>
</span></span><span style=display:flex><span>   <span style=color:#1c01ce>1</span>    <span style=color:#a90d91>int</span> <span style=color:#000>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#1c01ce>2</span>        <span style=color:#a90d91>int</span><span style=color:#000>*</span> <span style=color:#000>p</span> <span style=color:#000>=</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span><span style=color:#000>-&gt;</span> <span style=color:#1c01ce>3</span>        <span style=color:#a90d91>return</span> <span style=color:#1c01ce>0</span>;
</span></span><span style=display:flex><span>   <span style=color:#1c01ce>4</span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#000>lldb</span>) <span style=color:#000>p</span> <span style=color:#000>p</span> <span style=color:#000>==</span> <span style=color:#1c01ce>1</span>
</span></span><span style=display:flex><span>(<span style=color:#a90d91>bool</span>) <span style=color:#000>$</span><span style=color:#1c01ce>0</span> <span style=color:#000>=</span> <span style=color:#a90d91>false</span>
</span></span><span style=display:flex><span>(<span style=color:#000>lldb</span>) <span style=color:#000>p</span> <span style=color:#000>p</span> <span style=color:#000>==</span> <span style=color:#1c01ce>0</span>
</span></span><span style=display:flex><span>(<span style=color:#a90d91>bool</span>) <span style=color:#000>$</span><span style=color:#1c01ce>1</span> <span style=color:#000>=</span> <span style=color:#a90d91>true</span>
</span></span></code></pre></div><p>Clang <a href=https://github.com/llvm/llvm-project/blob/5b2d8503d1d4b925e30fd2b91f97bfd625f03157/clang/lib/Sema/SemaExpr.cpp#L11971-L11972>explicitly allows this</a> if the expression is being parsed in the debugger context. Same goes for <a href=https://github.com/llvm/llvm-project/blob/5b2d8503d1d4b925e30fd2b91f97bfd625f03157/clang/lib/Sema/SemaExprMember.cpp#L1421>accessing private and protected members</a> of classes and structs. <em>Of course</em> if someone types <code>foo->x_</code>, they don&rsquo;t expect to get <code>'x_' is a private member of 'Foo'</code>. That&rsquo;s why <code>lldb-eval</code> is less strict than the compiler and tries to do what the user expects in the given context.</p><p><img src=lldb-eval-vs-compiler.jpg alt=image width=1081 height=714></p><h2 id=interpreter>Interpreter
<a class=heading-link href=#interpreter>#</a></h2><p>The second core component in <code>lldb-eval</code> is the <code>Interpreter</code> (<a href=https://github.com/google/lldb-eval/blob/master/lldb-eval/eval.h>eval.h</a>). It takes the AST produced by the parser and recursively evaluates it. Typically interpreters convert the AST to some kind of <a href=https://en.wikipedia.org/wiki/Bytecode>bytecode</a> or <a href=https://en.wikipedia.org/wiki/Intermediate_representation>IR</a> first, but <code>lldb-eval</code> skips this step for simplicity.</p><p>Since the parser is guaranteed to produce a <em>valid</em> AST (or give a reasonable error), the <code>Interpreter</code> makes an assumption of correctness &ndash; all the types match, all casts are correct, all functions have correct number of arguments, etc. This doesn&rsquo;t prevent <em>runtime</em> errors though. For example, one can still dereference a null pointer &ndash; <code>*(int*)0 + 1</code>. The parser will be happy, but the interpreter will have to deal with zero pointer.</p><p>The interpreter implements a number of optimizations related to UB (undefined behavior) described in C++ specification. A little known fact, it&rsquo;s actually perfectly legal to dereference a null pointer <em>as long as the result of the dereference is not used</em>. For example, this is well-formed C++:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>int</span> <span style=color:#000>x</span> <span style=color:#000>=</span> <span style=color:#1c01ce>42</span>;
</span></span><span style=display:flex><span><span style=color:#a90d91>int</span><span style=color:#000>*</span> <span style=color:#000>p</span> <span style=color:#000>=</span> <span style=color:#000>&amp;</span>( <span style=color:#a90d91>true</span> <span style=color:#000>?</span> <span style=color:#000>*</span>(<span style=color:#a90d91>int</span><span style=color:#000>*</span>)<span style=color:#1c01ce>0</span> <span style=color:#000>:</span> <span style=color:#000>x</span> );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// `p + 1` is 1;
</span></span></span></code></pre></div><p>The interpreter performs flow control analysis, detects when the result of the dereference is not used and eliminates the &ldquo;pair&rdquo; operations of <code>&*</code>. Same logic also applies for member access (which is <em>basically</em> a dereference):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#a90d91>auto</span> <span style=color:#000>p</span> <span style=color:#000>=</span> <span style=color:#000>&amp;</span>((<span style=color:#000>Foo</span><span style=color:#000>*</span>)<span style=color:#1c01ce>0</span>)<span style=color:#000>-&gt;</span><span style=color:#000>foo_</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#177500>// `p` is the offset of `foo_` in `Foo`.
</span></span></span></code></pre></div><p>Implementing this properly, however, is more complicated, because in general it&rsquo;s not possible to calculate the offset &ldquo;statically&rdquo;. If the object in question has virtual base classes, the debug information might not contain all the required information and the offset should be calculated at runtime using the <a href=https://en.wikipedia.org/wiki/Virtual_method_table>vtable</a>. This is doable, but not yet implemented in <code>lldb-eval</code>.</p><h2 id=api>API
<a class=heading-link href=#api>#</a></h2><p><code>lldb-eval</code> has a minimalistic <a href=lldb-eval/api.h>API</a> which is very similar to LLDB API (not surprising, given that it builds on top on <code>LLDB</code>). The basic method looks like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBValue</span> <span style=color:#000>EvaluateExpression</span>(
</span></span><span style=display:flex><span>  <span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBFrame</span> <span style=color:#000>frame</span>, <span style=color:#a90d91>const</span> <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#000>expression</span>, <span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBError</span><span style=color:#000>&amp;</span> <span style=color:#000>error</span>);
</span></span></code></pre></div><p>Usually you&rsquo;d want the stack frame where the program is currently stopped, but it&rsquo;s possible to use any valid one (e.g. from another thread or to inspect the variables of the caller function).</p><p>There&rsquo;s a option of using <code>lldb::SBValue</code> instead of <code>lldb::SBFrame</code>, then the expression is evaluated in the context of the given object:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBValue</span> <span style=color:#000>EvaluateExpression</span>(
</span></span><span style=display:flex><span>  <span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBValue</span> <span style=color:#000>scope</span>, <span style=color:#a90d91>const</span> <span style=color:#a90d91>char</span><span style=color:#000>*</span> <span style=color:#000>expression</span>, <span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBError</span><span style=color:#000>&amp;</span> <span style=color:#000>error</span>);
</span></span></code></pre></div><p>For example, <code>this->foo_</code> or just <code>foo_</code> will refer to the member of the context object, not the variable in the current stack frame. This is very useful when evaluating custom visualization logic like <a href=https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects>NatVis</a>.</p><h3 id=maintaning-state>Maintaning state
<a class=heading-link href=#maintaning-state>#</a></h3><p><code>lldb-eval</code> is stateless (and thread-safe), but sometimes it&rsquo;s useful to have some state that the expressions can access and modify. For example, in NatVis <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019#customlistitems-expansion">CustomListItems</a> allows you to declare variables that can be modified by the expression. Typical examples &ndash; a counter or a pointer to a bucket in hash-table.</p><p>Both versions of <code>EvaluateExpression</code> allow passing of a list of external identifiers/values that can be used by the expression. This makes it possible to have a state between the expression evaluations, while keeping the library stateless:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBError</span> <span style=color:#000>ignore</span>;
</span></span><span style=display:flex><span><span style=color:#000>lldb</span><span style=color:#000>::</span><span style=color:#000>SBValue</span> <span style=color:#000>counter</span> <span style=color:#000>=</span> <span style=color:#000>lldb_eval</span><span style=color:#000>::</span><span style=color:#000>EvaluateExpression</span>(<span style=color:#000>frame</span>, <span style=color:#c41a16>&#34;10&#34;</span>, <span style=color:#000>ignore</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>lldb_eval</span><span style=color:#000>::</span><span style=color:#000>ContextVariable</span> <span style=color:#000>var</span>;
</span></span><span style=display:flex><span><span style=color:#000>var</span>.<span style=color:#000>name</span> <span style=color:#000>=</span> <span style=color:#c41a16>&#34;counter&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#000>var</span>.<span style=color:#000>value</span> <span style=color:#000>=</span> <span style=color:#000>counter</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>lldb_eval</span><span style=color:#000>::</span><span style=color:#000>ContextVariableList</span> <span style=color:#000>vars</span>;
</span></span><span style=display:flex><span><span style=color:#000>vars</span>.<span style=color:#000>data</span> <span style=color:#000>=</span> <span style=color:#000>&amp;</span><span style=color:#000>var</span>;
</span></span><span style=display:flex><span><span style=color:#000>vars</span>.<span style=color:#000>size</span> <span style=color:#000>=</span> <span style=color:#1c01ce>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a90d91>while</span> (<span style=color:#000>counter</span>.<span style=color:#000>GetValueAsUnsigned</span>() <span style=color:#000>&gt;</span> <span style=color:#1c01ce>0</span>) {
</span></span><span style=display:flex><span>  <span style=color:#000>lldb_eval</span><span style=color:#000>::</span><span style=color:#000>EvaluateExpression</span>(<span style=color:#000>frame</span>, <span style=color:#c41a16>&#34;--counter&#34;</span>, <span style=color:#000>vars</span>, <span style=color:#000>ignore</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The code above creates a <code>counter</code> with initial value of <code>10</code> and then decrements it in a loop.</p><h2 id=performance>Performance
<a class=heading-link href=#performance>#</a></h2><p>The performance of the expression evaluator depends a lot on several factors. The first and likely the biggest factor in most cases is the binary size and the amount of debug information and its format (PDB, DWARF4/DWARF5). The expression evaluator needs to resolve the types and the identifiers and the more of those the process has, the slower the lookups are. Regular DWARF is not optimized for lookups and LLDB has special auxiliary indexes to support fast lookup operations.</p><p>To solve this issues, a new section was introduced in DWARF5 &ndash; <code>.debug_names</code>. It contains a pre-built lookup hash table that can be loaded by the debugger and used &ldquo;as is&rdquo;, without the additional processing. This potentially can reduce the startup time, since the debugger no longer needs to build the indexes manually. However, the format of this hash table is not necessarily optimal and in my experiments I&rsquo;ve seen binaries with <em>extremely</em> unoptimal <code>.debug_names</code> structure. The section doesn&rsquo;t actually have just one hash table, but might contain multiple entries. If your binary has thousands of these hash tables, the performance is not going to be great. Your mileage may vary, of course, and this should be researched case by case.</p><p>Another big factor contributing to the overall performance is the latency to the target process. If you&rsquo;re debugging a program locally the latency can be considered negligible, but if the program runs on a remote machine this is a completely different story. Latency to the remote machine adds up with every command the debugger sends to the debug server. If you have a roundtrip of 10ms-100ms you can effectively send up to 100-10 commands per second. Executing only 10 expressions per second doesn&rsquo;t sound like a lot, right?</p><p>In both <code>LLDB</code> and <code>lldb-eval</code> not every evaluation involves sending commands to the remote process.
LLDB will try to interpret the expression locally first and only if that is not possible, it will execute the code remotely. For example, simple expression like <code>1 + 2</code> can be interpreted by the debugger host, but expressions with function calls must be executed at the target.</p><p>In <code>lldb-eval</code> all expressions are interpreted locally and the only communication with the target process we need is reading its memory (e.g. values of the variables). This information is cached in the debugger host, so network requests happen only when necessary. Unfortunately, LLDB&rsquo;s remote debugging protocol is not especially optimized for minimizing the amount of messages, so there is some inefficiency here. Optimizing the protocol could improve the overall performance (and not just for <code>lldb-eval</code>).</p><p>Overall, a rough baseline for <code>lldb-eval</code> is <code>~1ms</code> per expression evaluation. This gives us about 200 of expressions in 200ms, which is approximately the latency humans can observe and tolerate &ndash; everything above starts to feel sluggish. For comparison, expression evaluator in LLDB can take up to <code>50-100ms</code> per expression on the binaries in my testing lab. I understand it&rsquo;s a bold claim and needs some proof, so I&rsquo;m working on getting some &ldquo;publishable&rdquo; results and disclosing the setup of the testing lab.</p><hr><p>Discuss this article on <a href=https://lobste.rs/s/jvskdh/blazing_fast_expression_evaluation_for_c>lobste.rs</a></p><hr></article></main><footer>© 2017 - 2023 <a href=mailto:weratt@gmail.com>Andy Hippo</a>
(<a href=https://twitter.com/werat>@werat</a>)
· Licensed under <a href=https://github.com/werat/werat.github.io/blob/main/LICENSE>MIT</a></footer><script data-goatcounter=https://werat-dev.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>