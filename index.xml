<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>werat.dev</title><link>https://werat.dev/</link><description>Recent content on werat.dev</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 24 Feb 2023 13:00:00 +0100</lastBuildDate><atom:link href="https://werat.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Pretty Rust backtraces in raw terminal mode</title><link>https://werat.dev/blog/pretty-rust-backtraces-in-raw-terminal-mode/</link><pubDate>Fri, 24 Feb 2023 13:00:00 +0100</pubDate><guid>https://werat.dev/blog/pretty-rust-backtraces-in-raw-terminal-mode/</guid><description>&lt;p>In my efforts to get better at Rust I&amp;rsquo;ve recently been working on a terminal-based roguelike game ü¶Ä. One of the first things terminal-based applications (e.g. games, text editors, tools like &lt;code>top&lt;/code>) do at startup is switch the terminal into &lt;a href="https://en.wikipedia.org/wiki/Terminal_mode">raw mode&lt;/a>. This article is about a short journey of how-do-I-get-a-pretty-panic-backtrace-when-my-terminal-is-in-raw-mode.&lt;/p>
&lt;p>
&lt;img src="backtrace.png" alt="roguelike" width="1684" height="1186" />
&lt;/p></description></item><item><title>Debugging Wine with LLDB and VSCode</title><link>https://werat.dev/blog/debugging-wine-with-lldb-and-vscode/</link><pubDate>Wed, 26 Oct 2022 15:20:00 +0100</pubDate><guid>https://werat.dev/blog/debugging-wine-with-lldb-and-vscode/</guid><description>&lt;p>
&lt;img src="debugging-doggo.png" alt="DALL-E generated doggo debugging Wine" width="1961" height="856" />
&lt;/p>
&lt;p>In my &lt;a href="https://werat.dev/blog/how-wine-works-101/">previous post about Wine&lt;/a> I mentioned working on a debugger that is capable of debugging both the Wine layer and the Windows application running with it. Time to share some details!&lt;/p></description></item><item><title>How Wine works 101</title><link>https://werat.dev/blog/how-wine-works-101/</link><pubDate>Mon, 10 Oct 2022 21:20:00 +0100</pubDate><guid>https://werat.dev/blog/how-wine-works-101/</guid><description>Wine is a compatibility layer capable of running Windows applications on several POSIX-compliant operating systems, such as Linux, macOS, &amp;amp; BSD (https://www.winehq.org).
If you have been using Linux for some time now, chances are you‚Äôve used Wine at some point. Maybe to run that one very important Windows program that doesn‚Äôt have a Linux version or maybe to play World of Warcraft or some other game. Fun fact, Valve&amp;rsquo;s Steam Deck uses a Wine-based solution to run games (called Proton).</description></item><item><title>How to debug deadlocks in Visual Studio</title><link>https://werat.dev/blog/how-to-debug-deadlocks-in-visual-studio/</link><pubDate>Sat, 17 Sep 2022 12:21:00 +0100</pubDate><guid>https://werat.dev/blog/how-to-debug-deadlocks-in-visual-studio/</guid><description>There has been lots of discussions recently about the usefulness of debuggers (on Twitter/Reddit and probably other platforms). Some people brag about never using/needing one and some people can&amp;rsquo;t imagine their life without stepping through the code line by line. I&amp;rsquo;m both of these people at different times, so I&amp;rsquo;m not going to judge anyone. Instead, let me share a short debugging story and you can decide for yourself :)</description></item><item><title>Why are my PCHs out of date?</title><link>https://werat.dev/blog/why-are-my-pchs-out-of-date/</link><pubDate>Sat, 04 Dec 2021 13:35:00 +0100</pubDate><guid>https://werat.dev/blog/why-are-my-pchs-out-of-date/</guid><description>Last week I got an interesting bug report from a colleague. They were minding their own business and playing with Unreal Engine 5 when suddenly a wild build error appeared and said that some precompiled headers are out of date:
fatal error: file &amp;#39;D:\toolchain\sysroot\usr\include\x86_64-linux-gnu\bits\wordsize.h&amp;#39; has been modified since the precompiled header &amp;#39;UE5\Engine\...\SharedPCH.CoreUObject.ShadowErrors.h.gch&amp;#39; was built: mtime changed Hmm, well, it looks like some source files have changed and a simple re-build would fix the issue.</description></item><item><title>Installing Visual Studio extensions from MSI</title><link>https://werat.dev/blog/installing-visual-studio-extensions-from-msi/</link><pubDate>Sat, 07 Aug 2021 09:23:00 +0100</pubDate><guid>https://werat.dev/blog/installing-visual-studio-extensions-from-msi/</guid><description>Visual Studio extensions are typically distributed via VSIX packages. Visual Studio comes with an installer vsixinstaller.exe, which handles the actuall installation process. When you download the VSIX file from the extension gallery and then double-click it or when you install the extension from Visual Studio via the &amp;ldquo;Extensions and Updates&amp;rdquo; menu the above mentioned installer is invoked and does all the work. It&amp;rsquo;s also possible to use vsixinstaller.exe directly if you need to install the extensions programmatically (e.</description></item><item><title>Running benchmarks for Pull Requests via GitHub Actions</title><link>https://werat.dev/blog/running-benchmarks-for-pull-requests-via-github-actions/</link><pubDate>Mon, 28 Jun 2021 13:35:00 +0100</pubDate><guid>https://werat.dev/blog/running-benchmarks-for-pull-requests-via-github-actions/</guid><description>Benchmarks are often underestimated and don&amp;rsquo;t get the same attention as tests. However &amp;ldquo;performance is a feature&amp;rdquo; and when something is not tested it might as well be just broken. If the performance is not measured/tracked regressions are inevitable.
Modern tooling makes it really easy to write benchmarks. Some languages have built-in support, for example, Rust comes with cargo bench (docs) and Go has go test -bench (docs). For C++ there is google/benchmark &amp;ndash; not as streamlined as having it built into the language infrastructure, but still definitely worth the effort.</description></item><item><title>Blazing fast expression evaluation for C++ in LLDB</title><link>https://werat.dev/blog/blazing-fast-expression-evaluation-for-c-in-lldb/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>https://werat.dev/blog/blazing-fast-expression-evaluation-for-c-in-lldb/</guid><description>Expression evaluation is an integral part of any modern debugger. It allows the user to inspect the program state using the familiar syntax of the target language, as well as perform modifications to the target process (if the side-effects are allowed). If you have ever used command-line debuggers, you&amp;rsquo;re probably familiar with it via commands like print/call in GDB or expr/p in LLDB. It is also used extensively by the IDEs to support typical UI workflows: Immediate Window, Watch Window, hovering over a variable, custom data visualizers (see NatVis), etc.</description></item><item><title>Debugging LLDB with source stepping</title><link>https://werat.dev/blog/debugging-lldb-with-source-stepping/</link><pubDate>Sun, 11 Oct 2020 18:35:00 +0100</pubDate><guid>https://werat.dev/blog/debugging-lldb-with-source-stepping/</guid><description>Sometimes you want to (or need to) debug a program that you didn&amp;rsquo;t build yourself and you don&amp;rsquo;t even know how exactly it was built. Depending on the specifics of your setup that could mean many different things:
Built on a build farm, running on a production server/container Installed via apt or similar, running locally &amp;hellip; This post is inspired by my experience of debugging LLDB. Debugging the debugger is always interesting and tricky, even without the additional difficulties like trying to get the source stepping to work :)</description></item><item><title>Happy ssh agent forwarding for tmux/screen</title><link>https://werat.dev/blog/happy-ssh-agent-forwarding/</link><pubDate>Sat, 04 Feb 2017 11:55:00 +0300</pubDate><guid>https://werat.dev/blog/happy-ssh-agent-forwarding/</guid><description>If you often use ssh+tmux combination and ssh keys forwarding, you&amp;rsquo;ve definitely been in an unpleasant situation:
connect to some remote machine via ssh and create a tmux session use it happily detach from tmux and disconnect from server connect again (e.g. next day) and attach to the tmux session push something to git (or connect to another server)&amp;hellip; &amp;hellip; Permission denied (publickey). Let&amp;rsquo;s discuss why this is happening. The magic behind ssh forwarding is quite simple: ssh-agent creates a socket (on linux usually something like /tmp/ssh-hRNwjA1342/agent.</description></item><item><title>Talks</title><link>https://werat.dev/talks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://werat.dev/talks/</guid><description># Building a faster expression evaluator for LLDB # LLVM Developers&amp;rsquo; Meeting 2021 &amp;ndash; 17 November 2021 (video, slides)
# –ú–æ–¥–µ–ª—å –ø–∞–º—è—Ç–∏ C++ # Yandex C++ Party &amp;ndash; 18 December 2014 (video)</description></item></channel></rss>